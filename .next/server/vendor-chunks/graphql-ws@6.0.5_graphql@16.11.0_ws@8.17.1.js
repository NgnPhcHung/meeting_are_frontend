"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/graphql-ws@6.0.5_graphql@16.11.0_ws@8.17.1";
exports.ids = ["vendor-chunks/graphql-ws@6.0.5_graphql@16.11.0_ws@8.17.1"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/graphql-ws@6.0.5_graphql@16.11.0_ws@8.17.1/node_modules/graphql-ws/dist/client.js":
/*!**************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/graphql-ws@6.0.5_graphql@16.11.0_ws@8.17.1/node_modules/graphql-ws/dist/client.js ***!
  \**************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CloseCode: () => (/* reexport safe */ _common_CGW11Fyb_js__WEBPACK_IMPORTED_MODULE_0__.C),\n/* harmony export */   DEPRECATED_GRAPHQL_WS_PROTOCOL: () => (/* reexport safe */ _common_CGW11Fyb_js__WEBPACK_IMPORTED_MODULE_0__.D),\n/* harmony export */   GRAPHQL_TRANSPORT_WS_PROTOCOL: () => (/* reexport safe */ _common_CGW11Fyb_js__WEBPACK_IMPORTED_MODULE_0__.G),\n/* harmony export */   MessageType: () => (/* reexport safe */ _common_CGW11Fyb_js__WEBPACK_IMPORTED_MODULE_0__.M),\n/* harmony export */   TerminatedCloseEvent: () => (/* binding */ TerminatedCloseEvent),\n/* harmony export */   createClient: () => (/* binding */ createClient),\n/* harmony export */   parseMessage: () => (/* reexport safe */ _common_CGW11Fyb_js__WEBPACK_IMPORTED_MODULE_0__.p),\n/* harmony export */   stringifyMessage: () => (/* reexport safe */ _common_CGW11Fyb_js__WEBPACK_IMPORTED_MODULE_0__.s),\n/* harmony export */   validateMessage: () => (/* reexport safe */ _common_CGW11Fyb_js__WEBPACK_IMPORTED_MODULE_0__.v)\n/* harmony export */ });\n/* harmony import */ var _common_CGW11Fyb_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common-CGW11Fyb.js */ \"(ssr)/./node_modules/.pnpm/graphql-ws@6.0.5_graphql@16.11.0_ws@8.17.1/node_modules/graphql-ws/dist/common-CGW11Fyb.js\");\n\n\n\nfunction createClient(options) {\n  const {\n    url,\n    connectionParams,\n    lazy = true,\n    onNonLazyError = console.error,\n    lazyCloseTimeout: lazyCloseTimeoutMs = 0,\n    keepAlive = 0,\n    disablePong,\n    connectionAckWaitTimeout = 0,\n    retryAttempts = 5,\n    retryWait = async function randomisedExponentialBackoff(retries2) {\n      const retryDelaySeconds = Math.pow(2, retries2);\n      await new Promise(\n        (resolve) => setTimeout(\n          resolve,\n          retryDelaySeconds * 1e3 + // add random timeout from 300ms to 3s\n          Math.floor(Math.random() * (3e3 - 300) + 300)\n        )\n      );\n    },\n    shouldRetry = isLikeCloseEvent,\n    on,\n    webSocketImpl,\n    /**\n     * Generates a v4 UUID to be used as the ID using `Math`\n     * as the random number generator. Supply your own generator\n     * in case you need more uniqueness.\n     *\n     * Reference: https://gist.github.com/jed/982883\n     */\n    generateID = function generateUUID() {\n      return \"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx\".replace(/[xy]/g, (c) => {\n        const r = Math.random() * 16 | 0, v = c == \"x\" ? r : r & 3 | 8;\n        return v.toString(16);\n      });\n    },\n    jsonMessageReplacer: replacer,\n    jsonMessageReviver: reviver\n  } = options;\n  let ws;\n  if (webSocketImpl) {\n    if (!isWebSocket(webSocketImpl)) {\n      throw new Error(\"Invalid WebSocket implementation provided\");\n    }\n    ws = webSocketImpl;\n  } else if (typeof WebSocket !== \"undefined\") {\n    ws = WebSocket;\n  } else if (typeof global !== \"undefined\") {\n    ws = global.WebSocket || // @ts-expect-error: Support more browsers\n    global.MozWebSocket;\n  } else if (typeof window !== \"undefined\") {\n    ws = window.WebSocket || // @ts-expect-error: Support more browsers\n    window.MozWebSocket;\n  }\n  if (!ws)\n    throw new Error(\n      \"WebSocket implementation missing; on Node you can `import WebSocket from 'ws';` and pass `webSocketImpl: WebSocket` to `createClient`\"\n    );\n  const WebSocketImpl = ws;\n  const emitter = (() => {\n    const message = /* @__PURE__ */ (() => {\n      const listeners2 = {};\n      return {\n        on(id, listener) {\n          listeners2[id] = listener;\n          return () => {\n            delete listeners2[id];\n          };\n        },\n        emit(message2) {\n          if (\"id\" in message2) listeners2[message2.id]?.(message2);\n        }\n      };\n    })();\n    const listeners = {\n      connecting: on?.connecting ? [on.connecting] : [],\n      opened: on?.opened ? [on.opened] : [],\n      connected: on?.connected ? [on.connected] : [],\n      ping: on?.ping ? [on.ping] : [],\n      pong: on?.pong ? [on.pong] : [],\n      message: on?.message ? [message.emit, on.message] : [message.emit],\n      closed: on?.closed ? [on.closed] : [],\n      error: on?.error ? [on.error] : []\n    };\n    return {\n      onMessage: message.on,\n      on(event, listener) {\n        const l = listeners[event];\n        l.push(listener);\n        return () => {\n          l.splice(l.indexOf(listener), 1);\n        };\n      },\n      emit(event, ...args) {\n        for (const listener of [...listeners[event]]) {\n          listener(...args);\n        }\n      }\n    };\n  })();\n  function errorOrClosed(cb) {\n    const listening = [\n      // errors are fatal and more critical than close events, throw them first\n      emitter.on(\"error\", (err) => {\n        listening.forEach((unlisten) => unlisten());\n        cb(err);\n      }),\n      // closes can be graceful and not fatal, throw them second (if error didnt throw)\n      emitter.on(\"closed\", (event) => {\n        listening.forEach((unlisten) => unlisten());\n        cb(event);\n      })\n    ];\n  }\n  let connecting, locks = 0, lazyCloseTimeout, retrying = false, retries = 0, disposed = false;\n  async function connect() {\n    clearTimeout(lazyCloseTimeout);\n    const [socket, throwOnClose] = await (connecting ?? (connecting = new Promise(\n      (connected, denied) => (async () => {\n        if (retrying) {\n          await retryWait(retries);\n          if (!locks) {\n            connecting = undefined;\n            return denied({ code: 1e3, reason: \"All Subscriptions Gone\" });\n          }\n          retries++;\n        }\n        emitter.emit(\"connecting\", retrying);\n        const socket2 = new WebSocketImpl(\n          typeof url === \"function\" ? await url() : url,\n          _common_CGW11Fyb_js__WEBPACK_IMPORTED_MODULE_0__.G\n        );\n        let connectionAckTimeout, queuedPing;\n        function enqueuePing() {\n          if (isFinite(keepAlive) && keepAlive > 0) {\n            clearTimeout(queuedPing);\n            queuedPing = setTimeout(() => {\n              if (socket2.readyState === WebSocketImpl.OPEN) {\n                socket2.send((0,_common_CGW11Fyb_js__WEBPACK_IMPORTED_MODULE_0__.s)({ type: _common_CGW11Fyb_js__WEBPACK_IMPORTED_MODULE_0__.M.Ping }));\n                emitter.emit(\"ping\", false, undefined);\n              }\n            }, keepAlive);\n          }\n        }\n        errorOrClosed((errOrEvent) => {\n          connecting = undefined;\n          clearTimeout(connectionAckTimeout);\n          clearTimeout(queuedPing);\n          denied(errOrEvent);\n          if (errOrEvent instanceof TerminatedCloseEvent) {\n            socket2.close(4499, \"Terminated\");\n            socket2.onerror = null;\n            socket2.onclose = null;\n          }\n        });\n        socket2.onerror = (err) => emitter.emit(\"error\", err);\n        socket2.onclose = (event) => emitter.emit(\"closed\", event);\n        socket2.onopen = async () => {\n          try {\n            emitter.emit(\"opened\", socket2);\n            const payload = typeof connectionParams === \"function\" ? await connectionParams() : connectionParams;\n            if (socket2.readyState !== WebSocketImpl.OPEN) return;\n            socket2.send(\n              (0,_common_CGW11Fyb_js__WEBPACK_IMPORTED_MODULE_0__.s)(\n                payload ? {\n                  type: _common_CGW11Fyb_js__WEBPACK_IMPORTED_MODULE_0__.M.ConnectionInit,\n                  payload\n                } : {\n                  type: _common_CGW11Fyb_js__WEBPACK_IMPORTED_MODULE_0__.M.ConnectionInit\n                  // payload is completely absent if not provided\n                },\n                replacer\n              )\n            );\n            if (isFinite(connectionAckWaitTimeout) && connectionAckWaitTimeout > 0) {\n              connectionAckTimeout = setTimeout(() => {\n                socket2.close(\n                  _common_CGW11Fyb_js__WEBPACK_IMPORTED_MODULE_0__.C.ConnectionAcknowledgementTimeout,\n                  \"Connection acknowledgement timeout\"\n                );\n              }, connectionAckWaitTimeout);\n            }\n            enqueuePing();\n          } catch (err) {\n            emitter.emit(\"error\", err);\n            socket2.close(\n              _common_CGW11Fyb_js__WEBPACK_IMPORTED_MODULE_0__.C.InternalClientError,\n              (0,_common_CGW11Fyb_js__WEBPACK_IMPORTED_MODULE_0__.l)(\n                err instanceof Error ? err.message : String(err),\n                \"Internal client error\"\n              )\n            );\n          }\n        };\n        let acknowledged = false;\n        socket2.onmessage = ({ data }) => {\n          try {\n            const message = (0,_common_CGW11Fyb_js__WEBPACK_IMPORTED_MODULE_0__.p)(data, reviver);\n            emitter.emit(\"message\", message);\n            if (message.type === \"ping\" || message.type === \"pong\") {\n              emitter.emit(message.type, true, message.payload);\n              if (message.type === \"pong\") {\n                enqueuePing();\n              } else if (!disablePong) {\n                socket2.send(\n                  (0,_common_CGW11Fyb_js__WEBPACK_IMPORTED_MODULE_0__.s)(\n                    message.payload ? {\n                      type: _common_CGW11Fyb_js__WEBPACK_IMPORTED_MODULE_0__.M.Pong,\n                      payload: message.payload\n                    } : {\n                      type: _common_CGW11Fyb_js__WEBPACK_IMPORTED_MODULE_0__.M.Pong\n                      // payload is completely absent if not provided\n                    }\n                  )\n                );\n                emitter.emit(\"pong\", false, message.payload);\n              }\n              return;\n            }\n            if (acknowledged) return;\n            if (message.type !== _common_CGW11Fyb_js__WEBPACK_IMPORTED_MODULE_0__.M.ConnectionAck)\n              throw new Error(\n                `First message cannot be of type ${message.type}`\n              );\n            clearTimeout(connectionAckTimeout);\n            acknowledged = true;\n            emitter.emit(\"connected\", socket2, message.payload, retrying);\n            retrying = false;\n            retries = 0;\n            connected([\n              socket2,\n              new Promise((_, reject) => errorOrClosed(reject))\n            ]);\n          } catch (err) {\n            socket2.onmessage = null;\n            emitter.emit(\"error\", err);\n            socket2.close(\n              _common_CGW11Fyb_js__WEBPACK_IMPORTED_MODULE_0__.C.BadResponse,\n              (0,_common_CGW11Fyb_js__WEBPACK_IMPORTED_MODULE_0__.l)(\n                err instanceof Error ? err.message : String(err),\n                \"Bad response\"\n              )\n            );\n          }\n        };\n      })()\n    )));\n    if (socket.readyState === WebSocketImpl.CLOSING) await throwOnClose;\n    let release = () => {\n    };\n    const released = new Promise((resolve) => release = resolve);\n    return [\n      socket,\n      release,\n      Promise.race([\n        // wait for\n        released.then(() => {\n          if (!locks) {\n            const complete = () => socket.close(1e3, \"Normal Closure\");\n            if (isFinite(lazyCloseTimeoutMs) && lazyCloseTimeoutMs > 0) {\n              lazyCloseTimeout = setTimeout(() => {\n                if (socket.readyState === WebSocketImpl.OPEN) complete();\n              }, lazyCloseTimeoutMs);\n            } else {\n              complete();\n            }\n          }\n        }),\n        // or\n        throwOnClose\n      ])\n    ];\n  }\n  function shouldRetryConnectOrThrow(errOrCloseEvent) {\n    if (isLikeCloseEvent(errOrCloseEvent) && (isFatalInternalCloseCode(errOrCloseEvent.code) || [\n      _common_CGW11Fyb_js__WEBPACK_IMPORTED_MODULE_0__.C.InternalServerError,\n      _common_CGW11Fyb_js__WEBPACK_IMPORTED_MODULE_0__.C.InternalClientError,\n      _common_CGW11Fyb_js__WEBPACK_IMPORTED_MODULE_0__.C.BadRequest,\n      _common_CGW11Fyb_js__WEBPACK_IMPORTED_MODULE_0__.C.BadResponse,\n      _common_CGW11Fyb_js__WEBPACK_IMPORTED_MODULE_0__.C.Unauthorized,\n      // CloseCode.Forbidden, might grant access out after retry\n      _common_CGW11Fyb_js__WEBPACK_IMPORTED_MODULE_0__.C.SubprotocolNotAcceptable,\n      // CloseCode.ConnectionInitialisationTimeout, might not time out after retry\n      // CloseCode.ConnectionAcknowledgementTimeout, might not time out after retry\n      _common_CGW11Fyb_js__WEBPACK_IMPORTED_MODULE_0__.C.SubscriberAlreadyExists,\n      _common_CGW11Fyb_js__WEBPACK_IMPORTED_MODULE_0__.C.TooManyInitialisationRequests\n      // 4499, // Terminated, probably because the socket froze, we want to retry\n    ].includes(errOrCloseEvent.code)))\n      throw errOrCloseEvent;\n    if (disposed) return false;\n    if (isLikeCloseEvent(errOrCloseEvent) && errOrCloseEvent.code === 1e3)\n      return locks > 0;\n    if (!retryAttempts || retries >= retryAttempts) throw errOrCloseEvent;\n    if (!shouldRetry(errOrCloseEvent)) throw errOrCloseEvent;\n    return retrying = true;\n  }\n  if (!lazy) {\n    (async () => {\n      locks++;\n      for (; ; ) {\n        try {\n          const [, , throwOnClose] = await connect();\n          await throwOnClose;\n        } catch (errOrCloseEvent) {\n          try {\n            if (!shouldRetryConnectOrThrow(errOrCloseEvent)) return;\n          } catch (errOrCloseEvent2) {\n            return onNonLazyError?.(errOrCloseEvent2);\n          }\n        }\n      }\n    })();\n  }\n  function subscribe(payload, sink) {\n    const id = generateID(payload);\n    let done = false, errored = false, releaser = () => {\n      locks--;\n      done = true;\n    };\n    (async () => {\n      locks++;\n      for (; ; ) {\n        try {\n          const [socket, release, waitForReleaseOrThrowOnClose] = await connect();\n          if (done) return release();\n          const unlisten = emitter.onMessage(id, (message) => {\n            switch (message.type) {\n              case _common_CGW11Fyb_js__WEBPACK_IMPORTED_MODULE_0__.M.Next: {\n                sink.next(message.payload);\n                return;\n              }\n              case _common_CGW11Fyb_js__WEBPACK_IMPORTED_MODULE_0__.M.Error: {\n                errored = true, done = true;\n                sink.error(message.payload);\n                releaser();\n                return;\n              }\n              case _common_CGW11Fyb_js__WEBPACK_IMPORTED_MODULE_0__.M.Complete: {\n                done = true;\n                releaser();\n                return;\n              }\n            }\n          });\n          socket.send(\n            (0,_common_CGW11Fyb_js__WEBPACK_IMPORTED_MODULE_0__.s)(\n              {\n                id,\n                type: _common_CGW11Fyb_js__WEBPACK_IMPORTED_MODULE_0__.M.Subscribe,\n                payload\n              },\n              replacer\n            )\n          );\n          releaser = () => {\n            if (!done && socket.readyState === WebSocketImpl.OPEN)\n              socket.send(\n                (0,_common_CGW11Fyb_js__WEBPACK_IMPORTED_MODULE_0__.s)(\n                  {\n                    id,\n                    type: _common_CGW11Fyb_js__WEBPACK_IMPORTED_MODULE_0__.M.Complete\n                  },\n                  replacer\n                )\n              );\n            locks--;\n            done = true;\n            release();\n          };\n          await waitForReleaseOrThrowOnClose.finally(unlisten);\n          return;\n        } catch (errOrCloseEvent) {\n          if (!shouldRetryConnectOrThrow(errOrCloseEvent)) return;\n        }\n      }\n    })().then(() => {\n      if (!errored) sink.complete();\n    }).catch((err) => {\n      sink.error(err);\n    });\n    return () => {\n      if (!done) releaser();\n    };\n  }\n  return {\n    on: emitter.on,\n    subscribe,\n    iterate(request) {\n      const pending = [];\n      const deferred = {\n        done: false,\n        error: null,\n        resolve: () => {\n        }\n      };\n      const dispose = subscribe(request, {\n        next(val) {\n          pending.push(val);\n          deferred.resolve();\n        },\n        error(err) {\n          deferred.done = true;\n          deferred.error = err;\n          deferred.resolve();\n        },\n        complete() {\n          deferred.done = true;\n          deferred.resolve();\n        }\n      });\n      const iterator = async function* iterator2() {\n        for (; ; ) {\n          if (!pending.length) {\n            await new Promise((resolve) => deferred.resolve = resolve);\n          }\n          while (pending.length) {\n            yield pending.shift();\n          }\n          if (deferred.error) {\n            throw deferred.error;\n          }\n          if (deferred.done) {\n            return;\n          }\n        }\n      }();\n      iterator.throw = async (err) => {\n        if (!deferred.done) {\n          deferred.done = true;\n          deferred.error = err;\n          deferred.resolve();\n        }\n        return { done: true, value: undefined };\n      };\n      iterator.return = async () => {\n        dispose();\n        return { done: true, value: undefined };\n      };\n      return iterator;\n    },\n    async dispose() {\n      disposed = true;\n      if (connecting) {\n        const [socket] = await connecting;\n        socket.close(1e3, \"Normal Closure\");\n      }\n    },\n    terminate() {\n      if (connecting) {\n        emitter.emit(\"closed\", new TerminatedCloseEvent());\n      }\n    }\n  };\n}\nclass TerminatedCloseEvent extends Error {\n  name = \"TerminatedCloseEvent\";\n  message = \"4499: Terminated\";\n  code = 4499;\n  reason = \"Terminated\";\n  wasClean = false;\n}\nfunction isLikeCloseEvent(val) {\n  return (0,_common_CGW11Fyb_js__WEBPACK_IMPORTED_MODULE_0__.i)(val) && \"code\" in val && \"reason\" in val;\n}\nfunction isFatalInternalCloseCode(code) {\n  if ([\n    1e3,\n    // Normal Closure is not an erroneous close code\n    1001,\n    // Going Away\n    1006,\n    // Abnormal Closure\n    1005,\n    // No Status Received\n    1012,\n    // Service Restart\n    1013,\n    // Try Again Later\n    1014\n    // Bad Gateway\n  ].includes(code))\n    return false;\n  return code >= 1e3 && code <= 1999;\n}\nfunction isWebSocket(val) {\n  return typeof val === \"function\" && \"constructor\" in val && \"CLOSED\" in val && \"CLOSING\" in val && \"CONNECTING\" in val && \"OPEN\" in val;\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vZ3JhcGhxbC13c0A2LjAuNV9ncmFwaHFsQDE2LjExLjBfd3NAOC4xNy4xL25vZGVfbW9kdWxlcy9ncmFwaHFsLXdzL2Rpc3QvY2xpZW50LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFBNEw7QUFDM0Y7O0FBRWpHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLDRDQUE0QztBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsNkNBQTZDO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsa0RBQTZCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLHNEQUFnQixHQUFHLE1BQU0sa0RBQVcsT0FBTztBQUN4RTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxzREFBZ0I7QUFDOUI7QUFDQSx3QkFBd0Isa0RBQVc7QUFDbkM7QUFDQSxrQkFBa0I7QUFDbEIsd0JBQXdCLGtEQUFXO0FBQ25DO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixrREFBUztBQUMzQjtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLGNBQWMsa0RBQVM7QUFDdkIsY0FBYyxzREFBZ0I7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsTUFBTTtBQUNyQztBQUNBLDRCQUE0QixzREFBWTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0Esa0JBQWtCLHNEQUFnQjtBQUNsQztBQUNBLDRCQUE0QixrREFBVztBQUN2QztBQUNBLHNCQUFzQjtBQUN0Qiw0QkFBNEIsa0RBQVc7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGtEQUFXO0FBQzVDO0FBQ0EsbURBQW1ELGFBQWE7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsY0FBYyxrREFBUztBQUN2QixjQUFjLHNEQUFnQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2YsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sa0RBQVM7QUFDZixNQUFNLGtEQUFTO0FBQ2YsTUFBTSxrREFBUztBQUNmLE1BQU0sa0RBQVM7QUFDZixNQUFNLGtEQUFTO0FBQ2Y7QUFDQSxNQUFNLGtEQUFTO0FBQ2Y7QUFDQTtBQUNBLE1BQU0sa0RBQVM7QUFDZixNQUFNLGtEQUFTO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsa0RBQVc7QUFDOUI7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGtEQUFXO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsa0RBQVc7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFlBQVksc0RBQWdCO0FBQzVCO0FBQ0E7QUFDQSxzQkFBc0Isa0RBQVc7QUFDakM7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHNEQUFnQjtBQUNoQztBQUNBO0FBQ0EsMEJBQTBCLGtEQUFXO0FBQ3JDLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxzREFBUTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRXFJIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdWkvLi9ub2RlX21vZHVsZXMvLnBucG0vZ3JhcGhxbC13c0A2LjAuNV9ncmFwaHFsQDE2LjExLjBfd3NAOC4xNy4xL25vZGVfbW9kdWxlcy9ncmFwaHFsLXdzL2Rpc3QvY2xpZW50LmpzPzhmN2UiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRyBhcyBHUkFQSFFMX1RSQU5TUE9SVF9XU19QUk9UT0NPTCwgcyBhcyBzdHJpbmdpZnlNZXNzYWdlLCBNIGFzIE1lc3NhZ2VUeXBlLCBDIGFzIENsb3NlQ29kZSwgbCBhcyBsaW1pdENsb3NlUmVhc29uLCBwIGFzIHBhcnNlTWVzc2FnZSwgaSBhcyBpc09iamVjdCB9IGZyb20gJy4vY29tbW9uLUNHVzExRnliLmpzJztcbmV4cG9ydCB7IEQgYXMgREVQUkVDQVRFRF9HUkFQSFFMX1dTX1BST1RPQ09MLCB2IGFzIHZhbGlkYXRlTWVzc2FnZSB9IGZyb20gJy4vY29tbW9uLUNHVzExRnliLmpzJztcblxuZnVuY3Rpb24gY3JlYXRlQ2xpZW50KG9wdGlvbnMpIHtcbiAgY29uc3Qge1xuICAgIHVybCxcbiAgICBjb25uZWN0aW9uUGFyYW1zLFxuICAgIGxhenkgPSB0cnVlLFxuICAgIG9uTm9uTGF6eUVycm9yID0gY29uc29sZS5lcnJvcixcbiAgICBsYXp5Q2xvc2VUaW1lb3V0OiBsYXp5Q2xvc2VUaW1lb3V0TXMgPSAwLFxuICAgIGtlZXBBbGl2ZSA9IDAsXG4gICAgZGlzYWJsZVBvbmcsXG4gICAgY29ubmVjdGlvbkFja1dhaXRUaW1lb3V0ID0gMCxcbiAgICByZXRyeUF0dGVtcHRzID0gNSxcbiAgICByZXRyeVdhaXQgPSBhc3luYyBmdW5jdGlvbiByYW5kb21pc2VkRXhwb25lbnRpYWxCYWNrb2ZmKHJldHJpZXMyKSB7XG4gICAgICBjb25zdCByZXRyeURlbGF5U2Vjb25kcyA9IE1hdGgucG93KDIsIHJldHJpZXMyKTtcbiAgICAgIGF3YWl0IG5ldyBQcm9taXNlKFxuICAgICAgICAocmVzb2x2ZSkgPT4gc2V0VGltZW91dChcbiAgICAgICAgICByZXNvbHZlLFxuICAgICAgICAgIHJldHJ5RGVsYXlTZWNvbmRzICogMWUzICsgLy8gYWRkIHJhbmRvbSB0aW1lb3V0IGZyb20gMzAwbXMgdG8gM3NcbiAgICAgICAgICBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAoM2UzIC0gMzAwKSArIDMwMClcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICB9LFxuICAgIHNob3VsZFJldHJ5ID0gaXNMaWtlQ2xvc2VFdmVudCxcbiAgICBvbixcbiAgICB3ZWJTb2NrZXRJbXBsLFxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlcyBhIHY0IFVVSUQgdG8gYmUgdXNlZCBhcyB0aGUgSUQgdXNpbmcgYE1hdGhgXG4gICAgICogYXMgdGhlIHJhbmRvbSBudW1iZXIgZ2VuZXJhdG9yLiBTdXBwbHkgeW91ciBvd24gZ2VuZXJhdG9yXG4gICAgICogaW4gY2FzZSB5b3UgbmVlZCBtb3JlIHVuaXF1ZW5lc3MuXG4gICAgICpcbiAgICAgKiBSZWZlcmVuY2U6IGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL2plZC85ODI4ODNcbiAgICAgKi9cbiAgICBnZW5lcmF0ZUlEID0gZnVuY3Rpb24gZ2VuZXJhdGVVVUlEKCkge1xuICAgICAgcmV0dXJuIFwieHh4eHh4eHgteHh4eC00eHh4LXl4eHgteHh4eHh4eHh4eHh4XCIucmVwbGFjZSgvW3h5XS9nLCAoYykgPT4ge1xuICAgICAgICBjb25zdCByID0gTWF0aC5yYW5kb20oKSAqIDE2IHwgMCwgdiA9IGMgPT0gXCJ4XCIgPyByIDogciAmIDMgfCA4O1xuICAgICAgICByZXR1cm4gdi50b1N0cmluZygxNik7XG4gICAgICB9KTtcbiAgICB9LFxuICAgIGpzb25NZXNzYWdlUmVwbGFjZXI6IHJlcGxhY2VyLFxuICAgIGpzb25NZXNzYWdlUmV2aXZlcjogcmV2aXZlclxuICB9ID0gb3B0aW9ucztcbiAgbGV0IHdzO1xuICBpZiAod2ViU29ja2V0SW1wbCkge1xuICAgIGlmICghaXNXZWJTb2NrZXQod2ViU29ja2V0SW1wbCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgV2ViU29ja2V0IGltcGxlbWVudGF0aW9uIHByb3ZpZGVkXCIpO1xuICAgIH1cbiAgICB3cyA9IHdlYlNvY2tldEltcGw7XG4gIH0gZWxzZSBpZiAodHlwZW9mIFdlYlNvY2tldCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHdzID0gV2ViU29ja2V0O1xuICB9IGVsc2UgaWYgKHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICB3cyA9IGdsb2JhbC5XZWJTb2NrZXQgfHwgLy8gQHRzLWV4cGVjdC1lcnJvcjogU3VwcG9ydCBtb3JlIGJyb3dzZXJzXG4gICAgZ2xvYmFsLk1veldlYlNvY2tldDtcbiAgfSBlbHNlIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgd3MgPSB3aW5kb3cuV2ViU29ja2V0IHx8IC8vIEB0cy1leHBlY3QtZXJyb3I6IFN1cHBvcnQgbW9yZSBicm93c2Vyc1xuICAgIHdpbmRvdy5Nb3pXZWJTb2NrZXQ7XG4gIH1cbiAgaWYgKCF3cylcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBcIldlYlNvY2tldCBpbXBsZW1lbnRhdGlvbiBtaXNzaW5nOyBvbiBOb2RlIHlvdSBjYW4gYGltcG9ydCBXZWJTb2NrZXQgZnJvbSAnd3MnO2AgYW5kIHBhc3MgYHdlYlNvY2tldEltcGw6IFdlYlNvY2tldGAgdG8gYGNyZWF0ZUNsaWVudGBcIlxuICAgICk7XG4gIGNvbnN0IFdlYlNvY2tldEltcGwgPSB3cztcbiAgY29uc3QgZW1pdHRlciA9ICgoKSA9PiB7XG4gICAgY29uc3QgbWVzc2FnZSA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4ge1xuICAgICAgY29uc3QgbGlzdGVuZXJzMiA9IHt9O1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgb24oaWQsIGxpc3RlbmVyKSB7XG4gICAgICAgICAgbGlzdGVuZXJzMltpZF0gPSBsaXN0ZW5lcjtcbiAgICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgZGVsZXRlIGxpc3RlbmVyczJbaWRdO1xuICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIGVtaXQobWVzc2FnZTIpIHtcbiAgICAgICAgICBpZiAoXCJpZFwiIGluIG1lc3NhZ2UyKSBsaXN0ZW5lcnMyW21lc3NhZ2UyLmlkXT8uKG1lc3NhZ2UyKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9KSgpO1xuICAgIGNvbnN0IGxpc3RlbmVycyA9IHtcbiAgICAgIGNvbm5lY3Rpbmc6IG9uPy5jb25uZWN0aW5nID8gW29uLmNvbm5lY3RpbmddIDogW10sXG4gICAgICBvcGVuZWQ6IG9uPy5vcGVuZWQgPyBbb24ub3BlbmVkXSA6IFtdLFxuICAgICAgY29ubmVjdGVkOiBvbj8uY29ubmVjdGVkID8gW29uLmNvbm5lY3RlZF0gOiBbXSxcbiAgICAgIHBpbmc6IG9uPy5waW5nID8gW29uLnBpbmddIDogW10sXG4gICAgICBwb25nOiBvbj8ucG9uZyA/IFtvbi5wb25nXSA6IFtdLFxuICAgICAgbWVzc2FnZTogb24/Lm1lc3NhZ2UgPyBbbWVzc2FnZS5lbWl0LCBvbi5tZXNzYWdlXSA6IFttZXNzYWdlLmVtaXRdLFxuICAgICAgY2xvc2VkOiBvbj8uY2xvc2VkID8gW29uLmNsb3NlZF0gOiBbXSxcbiAgICAgIGVycm9yOiBvbj8uZXJyb3IgPyBbb24uZXJyb3JdIDogW11cbiAgICB9O1xuICAgIHJldHVybiB7XG4gICAgICBvbk1lc3NhZ2U6IG1lc3NhZ2Uub24sXG4gICAgICBvbihldmVudCwgbGlzdGVuZXIpIHtcbiAgICAgICAgY29uc3QgbCA9IGxpc3RlbmVyc1tldmVudF07XG4gICAgICAgIGwucHVzaChsaXN0ZW5lcik7XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgbC5zcGxpY2UobC5pbmRleE9mKGxpc3RlbmVyKSwgMSk7XG4gICAgICAgIH07XG4gICAgICB9LFxuICAgICAgZW1pdChldmVudCwgLi4uYXJncykge1xuICAgICAgICBmb3IgKGNvbnN0IGxpc3RlbmVyIG9mIFsuLi5saXN0ZW5lcnNbZXZlbnRdXSkge1xuICAgICAgICAgIGxpc3RlbmVyKC4uLmFyZ3MpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfSkoKTtcbiAgZnVuY3Rpb24gZXJyb3JPckNsb3NlZChjYikge1xuICAgIGNvbnN0IGxpc3RlbmluZyA9IFtcbiAgICAgIC8vIGVycm9ycyBhcmUgZmF0YWwgYW5kIG1vcmUgY3JpdGljYWwgdGhhbiBjbG9zZSBldmVudHMsIHRocm93IHRoZW0gZmlyc3RcbiAgICAgIGVtaXR0ZXIub24oXCJlcnJvclwiLCAoZXJyKSA9PiB7XG4gICAgICAgIGxpc3RlbmluZy5mb3JFYWNoKCh1bmxpc3RlbikgPT4gdW5saXN0ZW4oKSk7XG4gICAgICAgIGNiKGVycik7XG4gICAgICB9KSxcbiAgICAgIC8vIGNsb3NlcyBjYW4gYmUgZ3JhY2VmdWwgYW5kIG5vdCBmYXRhbCwgdGhyb3cgdGhlbSBzZWNvbmQgKGlmIGVycm9yIGRpZG50IHRocm93KVxuICAgICAgZW1pdHRlci5vbihcImNsb3NlZFwiLCAoZXZlbnQpID0+IHtcbiAgICAgICAgbGlzdGVuaW5nLmZvckVhY2goKHVubGlzdGVuKSA9PiB1bmxpc3RlbigpKTtcbiAgICAgICAgY2IoZXZlbnQpO1xuICAgICAgfSlcbiAgICBdO1xuICB9XG4gIGxldCBjb25uZWN0aW5nLCBsb2NrcyA9IDAsIGxhenlDbG9zZVRpbWVvdXQsIHJldHJ5aW5nID0gZmFsc2UsIHJldHJpZXMgPSAwLCBkaXNwb3NlZCA9IGZhbHNlO1xuICBhc3luYyBmdW5jdGlvbiBjb25uZWN0KCkge1xuICAgIGNsZWFyVGltZW91dChsYXp5Q2xvc2VUaW1lb3V0KTtcbiAgICBjb25zdCBbc29ja2V0LCB0aHJvd09uQ2xvc2VdID0gYXdhaXQgKGNvbm5lY3RpbmcgPz8gKGNvbm5lY3RpbmcgPSBuZXcgUHJvbWlzZShcbiAgICAgIChjb25uZWN0ZWQsIGRlbmllZCkgPT4gKGFzeW5jICgpID0+IHtcbiAgICAgICAgaWYgKHJldHJ5aW5nKSB7XG4gICAgICAgICAgYXdhaXQgcmV0cnlXYWl0KHJldHJpZXMpO1xuICAgICAgICAgIGlmICghbG9ja3MpIHtcbiAgICAgICAgICAgIGNvbm5lY3RpbmcgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICByZXR1cm4gZGVuaWVkKHsgY29kZTogMWUzLCByZWFzb246IFwiQWxsIFN1YnNjcmlwdGlvbnMgR29uZVwiIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXRyaWVzKys7XG4gICAgICAgIH1cbiAgICAgICAgZW1pdHRlci5lbWl0KFwiY29ubmVjdGluZ1wiLCByZXRyeWluZyk7XG4gICAgICAgIGNvbnN0IHNvY2tldDIgPSBuZXcgV2ViU29ja2V0SW1wbChcbiAgICAgICAgICB0eXBlb2YgdXJsID09PSBcImZ1bmN0aW9uXCIgPyBhd2FpdCB1cmwoKSA6IHVybCxcbiAgICAgICAgICBHUkFQSFFMX1RSQU5TUE9SVF9XU19QUk9UT0NPTFxuICAgICAgICApO1xuICAgICAgICBsZXQgY29ubmVjdGlvbkFja1RpbWVvdXQsIHF1ZXVlZFBpbmc7XG4gICAgICAgIGZ1bmN0aW9uIGVucXVldWVQaW5nKCkge1xuICAgICAgICAgIGlmIChpc0Zpbml0ZShrZWVwQWxpdmUpICYmIGtlZXBBbGl2ZSA+IDApIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dChxdWV1ZWRQaW5nKTtcbiAgICAgICAgICAgIHF1ZXVlZFBpbmcgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgaWYgKHNvY2tldDIucmVhZHlTdGF0ZSA9PT0gV2ViU29ja2V0SW1wbC5PUEVOKSB7XG4gICAgICAgICAgICAgICAgc29ja2V0Mi5zZW5kKHN0cmluZ2lmeU1lc3NhZ2UoeyB0eXBlOiBNZXNzYWdlVHlwZS5QaW5nIH0pKTtcbiAgICAgICAgICAgICAgICBlbWl0dGVyLmVtaXQoXCJwaW5nXCIsIGZhbHNlLCB1bmRlZmluZWQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBrZWVwQWxpdmUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlcnJvck9yQ2xvc2VkKChlcnJPckV2ZW50KSA9PiB7XG4gICAgICAgICAgY29ubmVjdGluZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBjbGVhclRpbWVvdXQoY29ubmVjdGlvbkFja1RpbWVvdXQpO1xuICAgICAgICAgIGNsZWFyVGltZW91dChxdWV1ZWRQaW5nKTtcbiAgICAgICAgICBkZW5pZWQoZXJyT3JFdmVudCk7XG4gICAgICAgICAgaWYgKGVyck9yRXZlbnQgaW5zdGFuY2VvZiBUZXJtaW5hdGVkQ2xvc2VFdmVudCkge1xuICAgICAgICAgICAgc29ja2V0Mi5jbG9zZSg0NDk5LCBcIlRlcm1pbmF0ZWRcIik7XG4gICAgICAgICAgICBzb2NrZXQyLm9uZXJyb3IgPSBudWxsO1xuICAgICAgICAgICAgc29ja2V0Mi5vbmNsb3NlID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBzb2NrZXQyLm9uZXJyb3IgPSAoZXJyKSA9PiBlbWl0dGVyLmVtaXQoXCJlcnJvclwiLCBlcnIpO1xuICAgICAgICBzb2NrZXQyLm9uY2xvc2UgPSAoZXZlbnQpID0+IGVtaXR0ZXIuZW1pdChcImNsb3NlZFwiLCBldmVudCk7XG4gICAgICAgIHNvY2tldDIub25vcGVuID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBlbWl0dGVyLmVtaXQoXCJvcGVuZWRcIiwgc29ja2V0Mik7XG4gICAgICAgICAgICBjb25zdCBwYXlsb2FkID0gdHlwZW9mIGNvbm5lY3Rpb25QYXJhbXMgPT09IFwiZnVuY3Rpb25cIiA/IGF3YWl0IGNvbm5lY3Rpb25QYXJhbXMoKSA6IGNvbm5lY3Rpb25QYXJhbXM7XG4gICAgICAgICAgICBpZiAoc29ja2V0Mi5yZWFkeVN0YXRlICE9PSBXZWJTb2NrZXRJbXBsLk9QRU4pIHJldHVybjtcbiAgICAgICAgICAgIHNvY2tldDIuc2VuZChcbiAgICAgICAgICAgICAgc3RyaW5naWZ5TWVzc2FnZShcbiAgICAgICAgICAgICAgICBwYXlsb2FkID8ge1xuICAgICAgICAgICAgICAgICAgdHlwZTogTWVzc2FnZVR5cGUuQ29ubmVjdGlvbkluaXQsXG4gICAgICAgICAgICAgICAgICBwYXlsb2FkXG4gICAgICAgICAgICAgICAgfSA6IHtcbiAgICAgICAgICAgICAgICAgIHR5cGU6IE1lc3NhZ2VUeXBlLkNvbm5lY3Rpb25Jbml0XG4gICAgICAgICAgICAgICAgICAvLyBwYXlsb2FkIGlzIGNvbXBsZXRlbHkgYWJzZW50IGlmIG5vdCBwcm92aWRlZFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgcmVwbGFjZXJcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGlmIChpc0Zpbml0ZShjb25uZWN0aW9uQWNrV2FpdFRpbWVvdXQpICYmIGNvbm5lY3Rpb25BY2tXYWl0VGltZW91dCA+IDApIHtcbiAgICAgICAgICAgICAgY29ubmVjdGlvbkFja1RpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICBzb2NrZXQyLmNsb3NlKFxuICAgICAgICAgICAgICAgICAgQ2xvc2VDb2RlLkNvbm5lY3Rpb25BY2tub3dsZWRnZW1lbnRUaW1lb3V0LFxuICAgICAgICAgICAgICAgICAgXCJDb25uZWN0aW9uIGFja25vd2xlZGdlbWVudCB0aW1lb3V0XCJcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB9LCBjb25uZWN0aW9uQWNrV2FpdFRpbWVvdXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZW5xdWV1ZVBpbmcoKTtcbiAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGVtaXR0ZXIuZW1pdChcImVycm9yXCIsIGVycik7XG4gICAgICAgICAgICBzb2NrZXQyLmNsb3NlKFxuICAgICAgICAgICAgICBDbG9zZUNvZGUuSW50ZXJuYWxDbGllbnRFcnJvcixcbiAgICAgICAgICAgICAgbGltaXRDbG9zZVJlYXNvbihcbiAgICAgICAgICAgICAgICBlcnIgaW5zdGFuY2VvZiBFcnJvciA/IGVyci5tZXNzYWdlIDogU3RyaW5nKGVyciksXG4gICAgICAgICAgICAgICAgXCJJbnRlcm5hbCBjbGllbnQgZXJyb3JcIlxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgbGV0IGFja25vd2xlZGdlZCA9IGZhbHNlO1xuICAgICAgICBzb2NrZXQyLm9ubWVzc2FnZSA9ICh7IGRhdGEgfSkgPT4ge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBtZXNzYWdlID0gcGFyc2VNZXNzYWdlKGRhdGEsIHJldml2ZXIpO1xuICAgICAgICAgICAgZW1pdHRlci5lbWl0KFwibWVzc2FnZVwiLCBtZXNzYWdlKTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLnR5cGUgPT09IFwicGluZ1wiIHx8IG1lc3NhZ2UudHlwZSA9PT0gXCJwb25nXCIpIHtcbiAgICAgICAgICAgICAgZW1pdHRlci5lbWl0KG1lc3NhZ2UudHlwZSwgdHJ1ZSwgbWVzc2FnZS5wYXlsb2FkKTtcbiAgICAgICAgICAgICAgaWYgKG1lc3NhZ2UudHlwZSA9PT0gXCJwb25nXCIpIHtcbiAgICAgICAgICAgICAgICBlbnF1ZXVlUGluZygpO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKCFkaXNhYmxlUG9uZykge1xuICAgICAgICAgICAgICAgIHNvY2tldDIuc2VuZChcbiAgICAgICAgICAgICAgICAgIHN0cmluZ2lmeU1lc3NhZ2UoXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UucGF5bG9hZCA/IHtcbiAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBNZXNzYWdlVHlwZS5Qb25nLFxuICAgICAgICAgICAgICAgICAgICAgIHBheWxvYWQ6IG1lc3NhZ2UucGF5bG9hZFxuICAgICAgICAgICAgICAgICAgICB9IDoge1xuICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IE1lc3NhZ2VUeXBlLlBvbmdcbiAgICAgICAgICAgICAgICAgICAgICAvLyBwYXlsb2FkIGlzIGNvbXBsZXRlbHkgYWJzZW50IGlmIG5vdCBwcm92aWRlZFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBlbWl0dGVyLmVtaXQoXCJwb25nXCIsIGZhbHNlLCBtZXNzYWdlLnBheWxvYWQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhY2tub3dsZWRnZWQpIHJldHVybjtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLnR5cGUgIT09IE1lc3NhZ2VUeXBlLkNvbm5lY3Rpb25BY2spXG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgICBgRmlyc3QgbWVzc2FnZSBjYW5ub3QgYmUgb2YgdHlwZSAke21lc3NhZ2UudHlwZX1gXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQoY29ubmVjdGlvbkFja1RpbWVvdXQpO1xuICAgICAgICAgICAgYWNrbm93bGVkZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIGVtaXR0ZXIuZW1pdChcImNvbm5lY3RlZFwiLCBzb2NrZXQyLCBtZXNzYWdlLnBheWxvYWQsIHJldHJ5aW5nKTtcbiAgICAgICAgICAgIHJldHJ5aW5nID0gZmFsc2U7XG4gICAgICAgICAgICByZXRyaWVzID0gMDtcbiAgICAgICAgICAgIGNvbm5lY3RlZChbXG4gICAgICAgICAgICAgIHNvY2tldDIsXG4gICAgICAgICAgICAgIG5ldyBQcm9taXNlKChfLCByZWplY3QpID0+IGVycm9yT3JDbG9zZWQocmVqZWN0KSlcbiAgICAgICAgICAgIF0pO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgc29ja2V0Mi5vbm1lc3NhZ2UgPSBudWxsO1xuICAgICAgICAgICAgZW1pdHRlci5lbWl0KFwiZXJyb3JcIiwgZXJyKTtcbiAgICAgICAgICAgIHNvY2tldDIuY2xvc2UoXG4gICAgICAgICAgICAgIENsb3NlQ29kZS5CYWRSZXNwb25zZSxcbiAgICAgICAgICAgICAgbGltaXRDbG9zZVJlYXNvbihcbiAgICAgICAgICAgICAgICBlcnIgaW5zdGFuY2VvZiBFcnJvciA/IGVyci5tZXNzYWdlIDogU3RyaW5nKGVyciksXG4gICAgICAgICAgICAgICAgXCJCYWQgcmVzcG9uc2VcIlxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH0pKClcbiAgICApKSk7XG4gICAgaWYgKHNvY2tldC5yZWFkeVN0YXRlID09PSBXZWJTb2NrZXRJbXBsLkNMT1NJTkcpIGF3YWl0IHRocm93T25DbG9zZTtcbiAgICBsZXQgcmVsZWFzZSA9ICgpID0+IHtcbiAgICB9O1xuICAgIGNvbnN0IHJlbGVhc2VkID0gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHJlbGVhc2UgPSByZXNvbHZlKTtcbiAgICByZXR1cm4gW1xuICAgICAgc29ja2V0LFxuICAgICAgcmVsZWFzZSxcbiAgICAgIFByb21pc2UucmFjZShbXG4gICAgICAgIC8vIHdhaXQgZm9yXG4gICAgICAgIHJlbGVhc2VkLnRoZW4oKCkgPT4ge1xuICAgICAgICAgIGlmICghbG9ja3MpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbXBsZXRlID0gKCkgPT4gc29ja2V0LmNsb3NlKDFlMywgXCJOb3JtYWwgQ2xvc3VyZVwiKTtcbiAgICAgICAgICAgIGlmIChpc0Zpbml0ZShsYXp5Q2xvc2VUaW1lb3V0TXMpICYmIGxhenlDbG9zZVRpbWVvdXRNcyA+IDApIHtcbiAgICAgICAgICAgICAgbGF6eUNsb3NlVGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChzb2NrZXQucmVhZHlTdGF0ZSA9PT0gV2ViU29ja2V0SW1wbC5PUEVOKSBjb21wbGV0ZSgpO1xuICAgICAgICAgICAgICB9LCBsYXp5Q2xvc2VUaW1lb3V0TXMpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgY29tcGxldGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pLFxuICAgICAgICAvLyBvclxuICAgICAgICB0aHJvd09uQ2xvc2VcbiAgICAgIF0pXG4gICAgXTtcbiAgfVxuICBmdW5jdGlvbiBzaG91bGRSZXRyeUNvbm5lY3RPclRocm93KGVyck9yQ2xvc2VFdmVudCkge1xuICAgIGlmIChpc0xpa2VDbG9zZUV2ZW50KGVyck9yQ2xvc2VFdmVudCkgJiYgKGlzRmF0YWxJbnRlcm5hbENsb3NlQ29kZShlcnJPckNsb3NlRXZlbnQuY29kZSkgfHwgW1xuICAgICAgQ2xvc2VDb2RlLkludGVybmFsU2VydmVyRXJyb3IsXG4gICAgICBDbG9zZUNvZGUuSW50ZXJuYWxDbGllbnRFcnJvcixcbiAgICAgIENsb3NlQ29kZS5CYWRSZXF1ZXN0LFxuICAgICAgQ2xvc2VDb2RlLkJhZFJlc3BvbnNlLFxuICAgICAgQ2xvc2VDb2RlLlVuYXV0aG9yaXplZCxcbiAgICAgIC8vIENsb3NlQ29kZS5Gb3JiaWRkZW4sIG1pZ2h0IGdyYW50IGFjY2VzcyBvdXQgYWZ0ZXIgcmV0cnlcbiAgICAgIENsb3NlQ29kZS5TdWJwcm90b2NvbE5vdEFjY2VwdGFibGUsXG4gICAgICAvLyBDbG9zZUNvZGUuQ29ubmVjdGlvbkluaXRpYWxpc2F0aW9uVGltZW91dCwgbWlnaHQgbm90IHRpbWUgb3V0IGFmdGVyIHJldHJ5XG4gICAgICAvLyBDbG9zZUNvZGUuQ29ubmVjdGlvbkFja25vd2xlZGdlbWVudFRpbWVvdXQsIG1pZ2h0IG5vdCB0aW1lIG91dCBhZnRlciByZXRyeVxuICAgICAgQ2xvc2VDb2RlLlN1YnNjcmliZXJBbHJlYWR5RXhpc3RzLFxuICAgICAgQ2xvc2VDb2RlLlRvb01hbnlJbml0aWFsaXNhdGlvblJlcXVlc3RzXG4gICAgICAvLyA0NDk5LCAvLyBUZXJtaW5hdGVkLCBwcm9iYWJseSBiZWNhdXNlIHRoZSBzb2NrZXQgZnJvemUsIHdlIHdhbnQgdG8gcmV0cnlcbiAgICBdLmluY2x1ZGVzKGVyck9yQ2xvc2VFdmVudC5jb2RlKSkpXG4gICAgICB0aHJvdyBlcnJPckNsb3NlRXZlbnQ7XG4gICAgaWYgKGRpc3Bvc2VkKSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKGlzTGlrZUNsb3NlRXZlbnQoZXJyT3JDbG9zZUV2ZW50KSAmJiBlcnJPckNsb3NlRXZlbnQuY29kZSA9PT0gMWUzKVxuICAgICAgcmV0dXJuIGxvY2tzID4gMDtcbiAgICBpZiAoIXJldHJ5QXR0ZW1wdHMgfHwgcmV0cmllcyA+PSByZXRyeUF0dGVtcHRzKSB0aHJvdyBlcnJPckNsb3NlRXZlbnQ7XG4gICAgaWYgKCFzaG91bGRSZXRyeShlcnJPckNsb3NlRXZlbnQpKSB0aHJvdyBlcnJPckNsb3NlRXZlbnQ7XG4gICAgcmV0dXJuIHJldHJ5aW5nID0gdHJ1ZTtcbiAgfVxuICBpZiAoIWxhenkpIHtcbiAgICAoYXN5bmMgKCkgPT4ge1xuICAgICAgbG9ja3MrKztcbiAgICAgIGZvciAoOyA7ICkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IFssICwgdGhyb3dPbkNsb3NlXSA9IGF3YWl0IGNvbm5lY3QoKTtcbiAgICAgICAgICBhd2FpdCB0aHJvd09uQ2xvc2U7XG4gICAgICAgIH0gY2F0Y2ggKGVyck9yQ2xvc2VFdmVudCkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoIXNob3VsZFJldHJ5Q29ubmVjdE9yVGhyb3coZXJyT3JDbG9zZUV2ZW50KSkgcmV0dXJuO1xuICAgICAgICAgIH0gY2F0Y2ggKGVyck9yQ2xvc2VFdmVudDIpIHtcbiAgICAgICAgICAgIHJldHVybiBvbk5vbkxhenlFcnJvcj8uKGVyck9yQ2xvc2VFdmVudDIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pKCk7XG4gIH1cbiAgZnVuY3Rpb24gc3Vic2NyaWJlKHBheWxvYWQsIHNpbmspIHtcbiAgICBjb25zdCBpZCA9IGdlbmVyYXRlSUQocGF5bG9hZCk7XG4gICAgbGV0IGRvbmUgPSBmYWxzZSwgZXJyb3JlZCA9IGZhbHNlLCByZWxlYXNlciA9ICgpID0+IHtcbiAgICAgIGxvY2tzLS07XG4gICAgICBkb25lID0gdHJ1ZTtcbiAgICB9O1xuICAgIChhc3luYyAoKSA9PiB7XG4gICAgICBsb2NrcysrO1xuICAgICAgZm9yICg7IDsgKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgW3NvY2tldCwgcmVsZWFzZSwgd2FpdEZvclJlbGVhc2VPclRocm93T25DbG9zZV0gPSBhd2FpdCBjb25uZWN0KCk7XG4gICAgICAgICAgaWYgKGRvbmUpIHJldHVybiByZWxlYXNlKCk7XG4gICAgICAgICAgY29uc3QgdW5saXN0ZW4gPSBlbWl0dGVyLm9uTWVzc2FnZShpZCwgKG1lc3NhZ2UpID0+IHtcbiAgICAgICAgICAgIHN3aXRjaCAobWVzc2FnZS50eXBlKSB7XG4gICAgICAgICAgICAgIGNhc2UgTWVzc2FnZVR5cGUuTmV4dDoge1xuICAgICAgICAgICAgICAgIHNpbmsubmV4dChtZXNzYWdlLnBheWxvYWQpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjYXNlIE1lc3NhZ2VUeXBlLkVycm9yOiB7XG4gICAgICAgICAgICAgICAgZXJyb3JlZCA9IHRydWUsIGRvbmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHNpbmsuZXJyb3IobWVzc2FnZS5wYXlsb2FkKTtcbiAgICAgICAgICAgICAgICByZWxlYXNlcigpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjYXNlIE1lc3NhZ2VUeXBlLkNvbXBsZXRlOiB7XG4gICAgICAgICAgICAgICAgZG9uZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgcmVsZWFzZXIoKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICBzb2NrZXQuc2VuZChcbiAgICAgICAgICAgIHN0cmluZ2lmeU1lc3NhZ2UoXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpZCxcbiAgICAgICAgICAgICAgICB0eXBlOiBNZXNzYWdlVHlwZS5TdWJzY3JpYmUsXG4gICAgICAgICAgICAgICAgcGF5bG9hZFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICByZXBsYWNlclxuICAgICAgICAgICAgKVxuICAgICAgICAgICk7XG4gICAgICAgICAgcmVsZWFzZXIgPSAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoIWRvbmUgJiYgc29ja2V0LnJlYWR5U3RhdGUgPT09IFdlYlNvY2tldEltcGwuT1BFTilcbiAgICAgICAgICAgICAgc29ja2V0LnNlbmQoXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5TWVzc2FnZShcbiAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IE1lc3NhZ2VUeXBlLkNvbXBsZXRlXG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgcmVwbGFjZXJcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICBsb2Nrcy0tO1xuICAgICAgICAgICAgZG9uZSA9IHRydWU7XG4gICAgICAgICAgICByZWxlYXNlKCk7XG4gICAgICAgICAgfTtcbiAgICAgICAgICBhd2FpdCB3YWl0Rm9yUmVsZWFzZU9yVGhyb3dPbkNsb3NlLmZpbmFsbHkodW5saXN0ZW4pO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSBjYXRjaCAoZXJyT3JDbG9zZUV2ZW50KSB7XG4gICAgICAgICAgaWYgKCFzaG91bGRSZXRyeUNvbm5lY3RPclRocm93KGVyck9yQ2xvc2VFdmVudCkpIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pKCkudGhlbigoKSA9PiB7XG4gICAgICBpZiAoIWVycm9yZWQpIHNpbmsuY29tcGxldGUoKTtcbiAgICB9KS5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICBzaW5rLmVycm9yKGVycik7XG4gICAgfSk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGlmICghZG9uZSkgcmVsZWFzZXIoKTtcbiAgICB9O1xuICB9XG4gIHJldHVybiB7XG4gICAgb246IGVtaXR0ZXIub24sXG4gICAgc3Vic2NyaWJlLFxuICAgIGl0ZXJhdGUocmVxdWVzdCkge1xuICAgICAgY29uc3QgcGVuZGluZyA9IFtdO1xuICAgICAgY29uc3QgZGVmZXJyZWQgPSB7XG4gICAgICAgIGRvbmU6IGZhbHNlLFxuICAgICAgICBlcnJvcjogbnVsbCxcbiAgICAgICAgcmVzb2x2ZTogKCkgPT4ge1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgY29uc3QgZGlzcG9zZSA9IHN1YnNjcmliZShyZXF1ZXN0LCB7XG4gICAgICAgIG5leHQodmFsKSB7XG4gICAgICAgICAgcGVuZGluZy5wdXNoKHZhbCk7XG4gICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZSgpO1xuICAgICAgICB9LFxuICAgICAgICBlcnJvcihlcnIpIHtcbiAgICAgICAgICBkZWZlcnJlZC5kb25lID0gdHJ1ZTtcbiAgICAgICAgICBkZWZlcnJlZC5lcnJvciA9IGVycjtcbiAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKCk7XG4gICAgICAgIH0sXG4gICAgICAgIGNvbXBsZXRlKCkge1xuICAgICAgICAgIGRlZmVycmVkLmRvbmUgPSB0cnVlO1xuICAgICAgICAgIGRlZmVycmVkLnJlc29sdmUoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBjb25zdCBpdGVyYXRvciA9IGFzeW5jIGZ1bmN0aW9uKiBpdGVyYXRvcjIoKSB7XG4gICAgICAgIGZvciAoOyA7ICkge1xuICAgICAgICAgIGlmICghcGVuZGluZy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiBkZWZlcnJlZC5yZXNvbHZlID0gcmVzb2x2ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHdoaWxlIChwZW5kaW5nLmxlbmd0aCkge1xuICAgICAgICAgICAgeWllbGQgcGVuZGluZy5zaGlmdCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZGVmZXJyZWQuZXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IGRlZmVycmVkLmVycm9yO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZGVmZXJyZWQuZG9uZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSgpO1xuICAgICAgaXRlcmF0b3IudGhyb3cgPSBhc3luYyAoZXJyKSA9PiB7XG4gICAgICAgIGlmICghZGVmZXJyZWQuZG9uZSkge1xuICAgICAgICAgIGRlZmVycmVkLmRvbmUgPSB0cnVlO1xuICAgICAgICAgIGRlZmVycmVkLmVycm9yID0gZXJyO1xuICAgICAgICAgIGRlZmVycmVkLnJlc29sdmUoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBkb25lOiB0cnVlLCB2YWx1ZTogdW5kZWZpbmVkIH07XG4gICAgICB9O1xuICAgICAgaXRlcmF0b3IucmV0dXJuID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICBkaXNwb3NlKCk7XG4gICAgICAgIHJldHVybiB7IGRvbmU6IHRydWUsIHZhbHVlOiB1bmRlZmluZWQgfTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gaXRlcmF0b3I7XG4gICAgfSxcbiAgICBhc3luYyBkaXNwb3NlKCkge1xuICAgICAgZGlzcG9zZWQgPSB0cnVlO1xuICAgICAgaWYgKGNvbm5lY3RpbmcpIHtcbiAgICAgICAgY29uc3QgW3NvY2tldF0gPSBhd2FpdCBjb25uZWN0aW5nO1xuICAgICAgICBzb2NrZXQuY2xvc2UoMWUzLCBcIk5vcm1hbCBDbG9zdXJlXCIpO1xuICAgICAgfVxuICAgIH0sXG4gICAgdGVybWluYXRlKCkge1xuICAgICAgaWYgKGNvbm5lY3RpbmcpIHtcbiAgICAgICAgZW1pdHRlci5lbWl0KFwiY2xvc2VkXCIsIG5ldyBUZXJtaW5hdGVkQ2xvc2VFdmVudCgpKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG5jbGFzcyBUZXJtaW5hdGVkQ2xvc2VFdmVudCBleHRlbmRzIEVycm9yIHtcbiAgbmFtZSA9IFwiVGVybWluYXRlZENsb3NlRXZlbnRcIjtcbiAgbWVzc2FnZSA9IFwiNDQ5OTogVGVybWluYXRlZFwiO1xuICBjb2RlID0gNDQ5OTtcbiAgcmVhc29uID0gXCJUZXJtaW5hdGVkXCI7XG4gIHdhc0NsZWFuID0gZmFsc2U7XG59XG5mdW5jdGlvbiBpc0xpa2VDbG9zZUV2ZW50KHZhbCkge1xuICByZXR1cm4gaXNPYmplY3QodmFsKSAmJiBcImNvZGVcIiBpbiB2YWwgJiYgXCJyZWFzb25cIiBpbiB2YWw7XG59XG5mdW5jdGlvbiBpc0ZhdGFsSW50ZXJuYWxDbG9zZUNvZGUoY29kZSkge1xuICBpZiAoW1xuICAgIDFlMyxcbiAgICAvLyBOb3JtYWwgQ2xvc3VyZSBpcyBub3QgYW4gZXJyb25lb3VzIGNsb3NlIGNvZGVcbiAgICAxMDAxLFxuICAgIC8vIEdvaW5nIEF3YXlcbiAgICAxMDA2LFxuICAgIC8vIEFibm9ybWFsIENsb3N1cmVcbiAgICAxMDA1LFxuICAgIC8vIE5vIFN0YXR1cyBSZWNlaXZlZFxuICAgIDEwMTIsXG4gICAgLy8gU2VydmljZSBSZXN0YXJ0XG4gICAgMTAxMyxcbiAgICAvLyBUcnkgQWdhaW4gTGF0ZXJcbiAgICAxMDE0XG4gICAgLy8gQmFkIEdhdGV3YXlcbiAgXS5pbmNsdWRlcyhjb2RlKSlcbiAgICByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBjb2RlID49IDFlMyAmJiBjb2RlIDw9IDE5OTk7XG59XG5mdW5jdGlvbiBpc1dlYlNvY2tldCh2YWwpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWwgPT09IFwiZnVuY3Rpb25cIiAmJiBcImNvbnN0cnVjdG9yXCIgaW4gdmFsICYmIFwiQ0xPU0VEXCIgaW4gdmFsICYmIFwiQ0xPU0lOR1wiIGluIHZhbCAmJiBcIkNPTk5FQ1RJTkdcIiBpbiB2YWwgJiYgXCJPUEVOXCIgaW4gdmFsO1xufVxuXG5leHBvcnQgeyBDbG9zZUNvZGUsIEdSQVBIUUxfVFJBTlNQT1JUX1dTX1BST1RPQ09MLCBNZXNzYWdlVHlwZSwgVGVybWluYXRlZENsb3NlRXZlbnQsIGNyZWF0ZUNsaWVudCwgcGFyc2VNZXNzYWdlLCBzdHJpbmdpZnlNZXNzYWdlIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/graphql-ws@6.0.5_graphql@16.11.0_ws@8.17.1/node_modules/graphql-ws/dist/client.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/graphql-ws@6.0.5_graphql@16.11.0_ws@8.17.1/node_modules/graphql-ws/dist/common-CGW11Fyb.js":
/*!***********************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/graphql-ws@6.0.5_graphql@16.11.0_ws@8.17.1/node_modules/graphql-ws/dist/common-CGW11Fyb.js ***!
  \***********************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   C: () => (/* binding */ CloseCode),\n/* harmony export */   D: () => (/* binding */ DEPRECATED_GRAPHQL_WS_PROTOCOL),\n/* harmony export */   G: () => (/* binding */ GRAPHQL_TRANSPORT_WS_PROTOCOL),\n/* harmony export */   M: () => (/* binding */ MessageType),\n/* harmony export */   a: () => (/* binding */ isAsyncGenerator),\n/* harmony export */   b: () => (/* binding */ isAsyncIterable),\n/* harmony export */   i: () => (/* binding */ isObject),\n/* harmony export */   l: () => (/* binding */ limitCloseReason),\n/* harmony export */   p: () => (/* binding */ parseMessage),\n/* harmony export */   s: () => (/* binding */ stringifyMessage),\n/* harmony export */   v: () => (/* binding */ validateMessage)\n/* harmony export */ });\nfunction extendedTypeof(val) {\n  if (val === null) {\n    return \"null\";\n  }\n  if (Array.isArray(val)) {\n    return \"array\";\n  }\n  return typeof val;\n}\nfunction isObject(val) {\n  return extendedTypeof(val) === \"object\";\n}\nfunction isAsyncIterable(val) {\n  return typeof Object(val)[Symbol.asyncIterator] === \"function\";\n}\nfunction isAsyncGenerator(val) {\n  return isObject(val) && typeof Object(val)[Symbol.asyncIterator] === \"function\" && typeof val.return === \"function\";\n}\nfunction areGraphQLFormattedErrors(obj) {\n  return Array.isArray(obj) && // must be at least one error\n  obj.length > 0 && // error has at least a message\n  obj.every((ob) => \"message\" in ob);\n}\nfunction limitCloseReason(reason, whenTooLong) {\n  return reason.length < 124 ? reason : whenTooLong;\n}\n\nconst GRAPHQL_TRANSPORT_WS_PROTOCOL = \"graphql-transport-ws\";\nconst DEPRECATED_GRAPHQL_WS_PROTOCOL = \"graphql-ws\";\nvar CloseCode = /* @__PURE__ */ ((CloseCode2) => {\n  CloseCode2[CloseCode2[\"InternalServerError\"] = 4500] = \"InternalServerError\";\n  CloseCode2[CloseCode2[\"InternalClientError\"] = 4005] = \"InternalClientError\";\n  CloseCode2[CloseCode2[\"BadRequest\"] = 4400] = \"BadRequest\";\n  CloseCode2[CloseCode2[\"BadResponse\"] = 4004] = \"BadResponse\";\n  CloseCode2[CloseCode2[\"Unauthorized\"] = 4401] = \"Unauthorized\";\n  CloseCode2[CloseCode2[\"Forbidden\"] = 4403] = \"Forbidden\";\n  CloseCode2[CloseCode2[\"SubprotocolNotAcceptable\"] = 4406] = \"SubprotocolNotAcceptable\";\n  CloseCode2[CloseCode2[\"ConnectionInitialisationTimeout\"] = 4408] = \"ConnectionInitialisationTimeout\";\n  CloseCode2[CloseCode2[\"ConnectionAcknowledgementTimeout\"] = 4504] = \"ConnectionAcknowledgementTimeout\";\n  CloseCode2[CloseCode2[\"SubscriberAlreadyExists\"] = 4409] = \"SubscriberAlreadyExists\";\n  CloseCode2[CloseCode2[\"TooManyInitialisationRequests\"] = 4429] = \"TooManyInitialisationRequests\";\n  return CloseCode2;\n})(CloseCode || {});\nvar MessageType = /* @__PURE__ */ ((MessageType2) => {\n  MessageType2[\"ConnectionInit\"] = \"connection_init\";\n  MessageType2[\"ConnectionAck\"] = \"connection_ack\";\n  MessageType2[\"Ping\"] = \"ping\";\n  MessageType2[\"Pong\"] = \"pong\";\n  MessageType2[\"Subscribe\"] = \"subscribe\";\n  MessageType2[\"Next\"] = \"next\";\n  MessageType2[\"Error\"] = \"error\";\n  MessageType2[\"Complete\"] = \"complete\";\n  return MessageType2;\n})(MessageType || {});\nfunction validateMessage(val) {\n  if (!isObject(val)) {\n    throw new Error(\n      `Message is expected to be an object, but got ${extendedTypeof(val)}`\n    );\n  }\n  if (!val.type) {\n    throw new Error(`Message is missing the 'type' property`);\n  }\n  if (typeof val.type !== \"string\") {\n    throw new Error(\n      `Message is expects the 'type' property to be a string, but got ${extendedTypeof(\n        val.type\n      )}`\n    );\n  }\n  switch (val.type) {\n    case \"connection_init\" /* ConnectionInit */:\n    case \"connection_ack\" /* ConnectionAck */:\n    case \"ping\" /* Ping */:\n    case \"pong\" /* Pong */: {\n      if (val.payload != null && !isObject(val.payload)) {\n        throw new Error(\n          `\"${val.type}\" message expects the 'payload' property to be an object or nullish or missing, but got \"${val.payload}\"`\n        );\n      }\n      break;\n    }\n    case \"subscribe\" /* Subscribe */: {\n      if (typeof val.id !== \"string\") {\n        throw new Error(\n          `\"${val.type}\" message expects the 'id' property to be a string, but got ${extendedTypeof(\n            val.id\n          )}`\n        );\n      }\n      if (!val.id) {\n        throw new Error(\n          `\"${val.type}\" message requires a non-empty 'id' property`\n        );\n      }\n      if (!isObject(val.payload)) {\n        throw new Error(\n          `\"${val.type}\" message expects the 'payload' property to be an object, but got ${extendedTypeof(\n            val.payload\n          )}`\n        );\n      }\n      if (typeof val.payload.query !== \"string\") {\n        throw new Error(\n          `\"${val.type}\" message payload expects the 'query' property to be a string, but got ${extendedTypeof(\n            val.payload.query\n          )}`\n        );\n      }\n      if (val.payload.variables != null && !isObject(val.payload.variables)) {\n        throw new Error(\n          `\"${val.type}\" message payload expects the 'variables' property to be a an object or nullish or missing, but got ${extendedTypeof(\n            val.payload.variables\n          )}`\n        );\n      }\n      if (val.payload.operationName != null && extendedTypeof(val.payload.operationName) !== \"string\") {\n        throw new Error(\n          `\"${val.type}\" message payload expects the 'operationName' property to be a string or nullish or missing, but got ${extendedTypeof(\n            val.payload.operationName\n          )}`\n        );\n      }\n      if (val.payload.extensions != null && !isObject(val.payload.extensions)) {\n        throw new Error(\n          `\"${val.type}\" message payload expects the 'extensions' property to be a an object or nullish or missing, but got ${extendedTypeof(\n            val.payload.extensions\n          )}`\n        );\n      }\n      break;\n    }\n    case \"next\" /* Next */: {\n      if (typeof val.id !== \"string\") {\n        throw new Error(\n          `\"${val.type}\" message expects the 'id' property to be a string, but got ${extendedTypeof(\n            val.id\n          )}`\n        );\n      }\n      if (!val.id) {\n        throw new Error(\n          `\"${val.type}\" message requires a non-empty 'id' property`\n        );\n      }\n      if (!isObject(val.payload)) {\n        throw new Error(\n          `\"${val.type}\" message expects the 'payload' property to be an object, but got ${extendedTypeof(\n            val.payload\n          )}`\n        );\n      }\n      break;\n    }\n    case \"error\" /* Error */: {\n      if (typeof val.id !== \"string\") {\n        throw new Error(\n          `\"${val.type}\" message expects the 'id' property to be a string, but got ${extendedTypeof(\n            val.id\n          )}`\n        );\n      }\n      if (!val.id) {\n        throw new Error(\n          `\"${val.type}\" message requires a non-empty 'id' property`\n        );\n      }\n      if (!areGraphQLFormattedErrors(val.payload)) {\n        throw new Error(\n          `\"${val.type}\" message expects the 'payload' property to be an array of GraphQL errors, but got ${JSON.stringify(\n            val.payload\n          )}`\n        );\n      }\n      break;\n    }\n    case \"complete\" /* Complete */: {\n      if (typeof val.id !== \"string\") {\n        throw new Error(\n          `\"${val.type}\" message expects the 'id' property to be a string, but got ${extendedTypeof(\n            val.id\n          )}`\n        );\n      }\n      if (!val.id) {\n        throw new Error(\n          `\"${val.type}\" message requires a non-empty 'id' property`\n        );\n      }\n      break;\n    }\n    default:\n      throw new Error(`Invalid message 'type' property \"${val.type}\"`);\n  }\n  return val;\n}\nfunction parseMessage(data, reviver) {\n  return validateMessage(\n    typeof data === \"string\" ? JSON.parse(data, reviver) : data\n  );\n}\nfunction stringifyMessage(msg, replacer) {\n  validateMessage(msg);\n  return JSON.stringify(msg, replacer);\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vZ3JhcGhxbC13c0A2LjAuNV9ncmFwaHFsQDE2LjExLjBfd3NAOC4xNy4xL25vZGVfbW9kdWxlcy9ncmFwaHFsLXdzL2Rpc3QvY29tbW9uLUNHVzExRnliLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGlCQUFpQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsbUJBQW1CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxvQkFBb0I7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RUFBd0U7QUFDeEU7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxTQUFTLDJGQUEyRixZQUFZO0FBQzlIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxTQUFTLDhEQUE4RDtBQUNyRjtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsU0FBUztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsU0FBUyxvRUFBb0U7QUFDM0Y7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFNBQVMseUVBQXlFO0FBQ2hHO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxTQUFTLHNHQUFzRztBQUM3SDtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsU0FBUyx1R0FBdUc7QUFDOUg7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFNBQVMsdUdBQXVHO0FBQzlIO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxTQUFTLDhEQUE4RDtBQUNyRjtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsU0FBUztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsU0FBUyxvRUFBb0U7QUFDM0Y7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFNBQVMsOERBQThEO0FBQ3JGO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxTQUFTLHFGQUFxRjtBQUM1RztBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsU0FBUyw4REFBOEQ7QUFDckY7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFNBQVM7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCxTQUFTO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFd1EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly91aS8uL25vZGVfbW9kdWxlcy8ucG5wbS9ncmFwaHFsLXdzQDYuMC41X2dyYXBocWxAMTYuMTEuMF93c0A4LjE3LjEvbm9kZV9tb2R1bGVzL2dyYXBocWwtd3MvZGlzdC9jb21tb24tQ0dXMTFGeWIuanM/YTA2NSJdLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiBleHRlbmRlZFR5cGVvZih2YWwpIHtcbiAgaWYgKHZhbCA9PT0gbnVsbCkge1xuICAgIHJldHVybiBcIm51bGxcIjtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheSh2YWwpKSB7XG4gICAgcmV0dXJuIFwiYXJyYXlcIjtcbiAgfVxuICByZXR1cm4gdHlwZW9mIHZhbDtcbn1cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbCkge1xuICByZXR1cm4gZXh0ZW5kZWRUeXBlb2YodmFsKSA9PT0gXCJvYmplY3RcIjtcbn1cbmZ1bmN0aW9uIGlzQXN5bmNJdGVyYWJsZSh2YWwpIHtcbiAgcmV0dXJuIHR5cGVvZiBPYmplY3QodmFsKVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPT09IFwiZnVuY3Rpb25cIjtcbn1cbmZ1bmN0aW9uIGlzQXN5bmNHZW5lcmF0b3IodmFsKSB7XG4gIHJldHVybiBpc09iamVjdCh2YWwpICYmIHR5cGVvZiBPYmplY3QodmFsKVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgdmFsLnJldHVybiA9PT0gXCJmdW5jdGlvblwiO1xufVxuZnVuY3Rpb24gYXJlR3JhcGhRTEZvcm1hdHRlZEVycm9ycyhvYmopIHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkob2JqKSAmJiAvLyBtdXN0IGJlIGF0IGxlYXN0IG9uZSBlcnJvclxuICBvYmoubGVuZ3RoID4gMCAmJiAvLyBlcnJvciBoYXMgYXQgbGVhc3QgYSBtZXNzYWdlXG4gIG9iai5ldmVyeSgob2IpID0+IFwibWVzc2FnZVwiIGluIG9iKTtcbn1cbmZ1bmN0aW9uIGxpbWl0Q2xvc2VSZWFzb24ocmVhc29uLCB3aGVuVG9vTG9uZykge1xuICByZXR1cm4gcmVhc29uLmxlbmd0aCA8IDEyNCA/IHJlYXNvbiA6IHdoZW5Ub29Mb25nO1xufVxuXG5jb25zdCBHUkFQSFFMX1RSQU5TUE9SVF9XU19QUk9UT0NPTCA9IFwiZ3JhcGhxbC10cmFuc3BvcnQtd3NcIjtcbmNvbnN0IERFUFJFQ0FURURfR1JBUEhRTF9XU19QUk9UT0NPTCA9IFwiZ3JhcGhxbC13c1wiO1xudmFyIENsb3NlQ29kZSA9IC8qIEBfX1BVUkVfXyAqLyAoKENsb3NlQ29kZTIpID0+IHtcbiAgQ2xvc2VDb2RlMltDbG9zZUNvZGUyW1wiSW50ZXJuYWxTZXJ2ZXJFcnJvclwiXSA9IDQ1MDBdID0gXCJJbnRlcm5hbFNlcnZlckVycm9yXCI7XG4gIENsb3NlQ29kZTJbQ2xvc2VDb2RlMltcIkludGVybmFsQ2xpZW50RXJyb3JcIl0gPSA0MDA1XSA9IFwiSW50ZXJuYWxDbGllbnRFcnJvclwiO1xuICBDbG9zZUNvZGUyW0Nsb3NlQ29kZTJbXCJCYWRSZXF1ZXN0XCJdID0gNDQwMF0gPSBcIkJhZFJlcXVlc3RcIjtcbiAgQ2xvc2VDb2RlMltDbG9zZUNvZGUyW1wiQmFkUmVzcG9uc2VcIl0gPSA0MDA0XSA9IFwiQmFkUmVzcG9uc2VcIjtcbiAgQ2xvc2VDb2RlMltDbG9zZUNvZGUyW1wiVW5hdXRob3JpemVkXCJdID0gNDQwMV0gPSBcIlVuYXV0aG9yaXplZFwiO1xuICBDbG9zZUNvZGUyW0Nsb3NlQ29kZTJbXCJGb3JiaWRkZW5cIl0gPSA0NDAzXSA9IFwiRm9yYmlkZGVuXCI7XG4gIENsb3NlQ29kZTJbQ2xvc2VDb2RlMltcIlN1YnByb3RvY29sTm90QWNjZXB0YWJsZVwiXSA9IDQ0MDZdID0gXCJTdWJwcm90b2NvbE5vdEFjY2VwdGFibGVcIjtcbiAgQ2xvc2VDb2RlMltDbG9zZUNvZGUyW1wiQ29ubmVjdGlvbkluaXRpYWxpc2F0aW9uVGltZW91dFwiXSA9IDQ0MDhdID0gXCJDb25uZWN0aW9uSW5pdGlhbGlzYXRpb25UaW1lb3V0XCI7XG4gIENsb3NlQ29kZTJbQ2xvc2VDb2RlMltcIkNvbm5lY3Rpb25BY2tub3dsZWRnZW1lbnRUaW1lb3V0XCJdID0gNDUwNF0gPSBcIkNvbm5lY3Rpb25BY2tub3dsZWRnZW1lbnRUaW1lb3V0XCI7XG4gIENsb3NlQ29kZTJbQ2xvc2VDb2RlMltcIlN1YnNjcmliZXJBbHJlYWR5RXhpc3RzXCJdID0gNDQwOV0gPSBcIlN1YnNjcmliZXJBbHJlYWR5RXhpc3RzXCI7XG4gIENsb3NlQ29kZTJbQ2xvc2VDb2RlMltcIlRvb01hbnlJbml0aWFsaXNhdGlvblJlcXVlc3RzXCJdID0gNDQyOV0gPSBcIlRvb01hbnlJbml0aWFsaXNhdGlvblJlcXVlc3RzXCI7XG4gIHJldHVybiBDbG9zZUNvZGUyO1xufSkoQ2xvc2VDb2RlIHx8IHt9KTtcbnZhciBNZXNzYWdlVHlwZSA9IC8qIEBfX1BVUkVfXyAqLyAoKE1lc3NhZ2VUeXBlMikgPT4ge1xuICBNZXNzYWdlVHlwZTJbXCJDb25uZWN0aW9uSW5pdFwiXSA9IFwiY29ubmVjdGlvbl9pbml0XCI7XG4gIE1lc3NhZ2VUeXBlMltcIkNvbm5lY3Rpb25BY2tcIl0gPSBcImNvbm5lY3Rpb25fYWNrXCI7XG4gIE1lc3NhZ2VUeXBlMltcIlBpbmdcIl0gPSBcInBpbmdcIjtcbiAgTWVzc2FnZVR5cGUyW1wiUG9uZ1wiXSA9IFwicG9uZ1wiO1xuICBNZXNzYWdlVHlwZTJbXCJTdWJzY3JpYmVcIl0gPSBcInN1YnNjcmliZVwiO1xuICBNZXNzYWdlVHlwZTJbXCJOZXh0XCJdID0gXCJuZXh0XCI7XG4gIE1lc3NhZ2VUeXBlMltcIkVycm9yXCJdID0gXCJlcnJvclwiO1xuICBNZXNzYWdlVHlwZTJbXCJDb21wbGV0ZVwiXSA9IFwiY29tcGxldGVcIjtcbiAgcmV0dXJuIE1lc3NhZ2VUeXBlMjtcbn0pKE1lc3NhZ2VUeXBlIHx8IHt9KTtcbmZ1bmN0aW9uIHZhbGlkYXRlTWVzc2FnZSh2YWwpIHtcbiAgaWYgKCFpc09iamVjdCh2YWwpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYE1lc3NhZ2UgaXMgZXhwZWN0ZWQgdG8gYmUgYW4gb2JqZWN0LCBidXQgZ290ICR7ZXh0ZW5kZWRUeXBlb2YodmFsKX1gXG4gICAgKTtcbiAgfVxuICBpZiAoIXZhbC50eXBlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBNZXNzYWdlIGlzIG1pc3NpbmcgdGhlICd0eXBlJyBwcm9wZXJ0eWApO1xuICB9XG4gIGlmICh0eXBlb2YgdmFsLnR5cGUgIT09IFwic3RyaW5nXCIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgTWVzc2FnZSBpcyBleHBlY3RzIHRoZSAndHlwZScgcHJvcGVydHkgdG8gYmUgYSBzdHJpbmcsIGJ1dCBnb3QgJHtleHRlbmRlZFR5cGVvZihcbiAgICAgICAgdmFsLnR5cGVcbiAgICAgICl9YFxuICAgICk7XG4gIH1cbiAgc3dpdGNoICh2YWwudHlwZSkge1xuICAgIGNhc2UgXCJjb25uZWN0aW9uX2luaXRcIiAvKiBDb25uZWN0aW9uSW5pdCAqLzpcbiAgICBjYXNlIFwiY29ubmVjdGlvbl9hY2tcIiAvKiBDb25uZWN0aW9uQWNrICovOlxuICAgIGNhc2UgXCJwaW5nXCIgLyogUGluZyAqLzpcbiAgICBjYXNlIFwicG9uZ1wiIC8qIFBvbmcgKi86IHtcbiAgICAgIGlmICh2YWwucGF5bG9hZCAhPSBudWxsICYmICFpc09iamVjdCh2YWwucGF5bG9hZCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGBcIiR7dmFsLnR5cGV9XCIgbWVzc2FnZSBleHBlY3RzIHRoZSAncGF5bG9hZCcgcHJvcGVydHkgdG8gYmUgYW4gb2JqZWN0IG9yIG51bGxpc2ggb3IgbWlzc2luZywgYnV0IGdvdCBcIiR7dmFsLnBheWxvYWR9XCJgXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSBcInN1YnNjcmliZVwiIC8qIFN1YnNjcmliZSAqLzoge1xuICAgICAgaWYgKHR5cGVvZiB2YWwuaWQgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGBcIiR7dmFsLnR5cGV9XCIgbWVzc2FnZSBleHBlY3RzIHRoZSAnaWQnIHByb3BlcnR5IHRvIGJlIGEgc3RyaW5nLCBidXQgZ290ICR7ZXh0ZW5kZWRUeXBlb2YoXG4gICAgICAgICAgICB2YWwuaWRcbiAgICAgICAgICApfWBcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmICghdmFsLmlkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBgXCIke3ZhbC50eXBlfVwiIG1lc3NhZ2UgcmVxdWlyZXMgYSBub24tZW1wdHkgJ2lkJyBwcm9wZXJ0eWBcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmICghaXNPYmplY3QodmFsLnBheWxvYWQpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBgXCIke3ZhbC50eXBlfVwiIG1lc3NhZ2UgZXhwZWN0cyB0aGUgJ3BheWxvYWQnIHByb3BlcnR5IHRvIGJlIGFuIG9iamVjdCwgYnV0IGdvdCAke2V4dGVuZGVkVHlwZW9mKFxuICAgICAgICAgICAgdmFsLnBheWxvYWRcbiAgICAgICAgICApfWBcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgdmFsLnBheWxvYWQucXVlcnkgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGBcIiR7dmFsLnR5cGV9XCIgbWVzc2FnZSBwYXlsb2FkIGV4cGVjdHMgdGhlICdxdWVyeScgcHJvcGVydHkgdG8gYmUgYSBzdHJpbmcsIGJ1dCBnb3QgJHtleHRlbmRlZFR5cGVvZihcbiAgICAgICAgICAgIHZhbC5wYXlsb2FkLnF1ZXJ5XG4gICAgICAgICAgKX1gXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAodmFsLnBheWxvYWQudmFyaWFibGVzICE9IG51bGwgJiYgIWlzT2JqZWN0KHZhbC5wYXlsb2FkLnZhcmlhYmxlcykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGBcIiR7dmFsLnR5cGV9XCIgbWVzc2FnZSBwYXlsb2FkIGV4cGVjdHMgdGhlICd2YXJpYWJsZXMnIHByb3BlcnR5IHRvIGJlIGEgYW4gb2JqZWN0IG9yIG51bGxpc2ggb3IgbWlzc2luZywgYnV0IGdvdCAke2V4dGVuZGVkVHlwZW9mKFxuICAgICAgICAgICAgdmFsLnBheWxvYWQudmFyaWFibGVzXG4gICAgICAgICAgKX1gXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAodmFsLnBheWxvYWQub3BlcmF0aW9uTmFtZSAhPSBudWxsICYmIGV4dGVuZGVkVHlwZW9mKHZhbC5wYXlsb2FkLm9wZXJhdGlvbk5hbWUpICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBgXCIke3ZhbC50eXBlfVwiIG1lc3NhZ2UgcGF5bG9hZCBleHBlY3RzIHRoZSAnb3BlcmF0aW9uTmFtZScgcHJvcGVydHkgdG8gYmUgYSBzdHJpbmcgb3IgbnVsbGlzaCBvciBtaXNzaW5nLCBidXQgZ290ICR7ZXh0ZW5kZWRUeXBlb2YoXG4gICAgICAgICAgICB2YWwucGF5bG9hZC5vcGVyYXRpb25OYW1lXG4gICAgICAgICAgKX1gXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAodmFsLnBheWxvYWQuZXh0ZW5zaW9ucyAhPSBudWxsICYmICFpc09iamVjdCh2YWwucGF5bG9hZC5leHRlbnNpb25zKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgYFwiJHt2YWwudHlwZX1cIiBtZXNzYWdlIHBheWxvYWQgZXhwZWN0cyB0aGUgJ2V4dGVuc2lvbnMnIHByb3BlcnR5IHRvIGJlIGEgYW4gb2JqZWN0IG9yIG51bGxpc2ggb3IgbWlzc2luZywgYnV0IGdvdCAke2V4dGVuZGVkVHlwZW9mKFxuICAgICAgICAgICAgdmFsLnBheWxvYWQuZXh0ZW5zaW9uc1xuICAgICAgICAgICl9YFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgXCJuZXh0XCIgLyogTmV4dCAqLzoge1xuICAgICAgaWYgKHR5cGVvZiB2YWwuaWQgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGBcIiR7dmFsLnR5cGV9XCIgbWVzc2FnZSBleHBlY3RzIHRoZSAnaWQnIHByb3BlcnR5IHRvIGJlIGEgc3RyaW5nLCBidXQgZ290ICR7ZXh0ZW5kZWRUeXBlb2YoXG4gICAgICAgICAgICB2YWwuaWRcbiAgICAgICAgICApfWBcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmICghdmFsLmlkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBgXCIke3ZhbC50eXBlfVwiIG1lc3NhZ2UgcmVxdWlyZXMgYSBub24tZW1wdHkgJ2lkJyBwcm9wZXJ0eWBcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmICghaXNPYmplY3QodmFsLnBheWxvYWQpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBgXCIke3ZhbC50eXBlfVwiIG1lc3NhZ2UgZXhwZWN0cyB0aGUgJ3BheWxvYWQnIHByb3BlcnR5IHRvIGJlIGFuIG9iamVjdCwgYnV0IGdvdCAke2V4dGVuZGVkVHlwZW9mKFxuICAgICAgICAgICAgdmFsLnBheWxvYWRcbiAgICAgICAgICApfWBcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIFwiZXJyb3JcIiAvKiBFcnJvciAqLzoge1xuICAgICAgaWYgKHR5cGVvZiB2YWwuaWQgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGBcIiR7dmFsLnR5cGV9XCIgbWVzc2FnZSBleHBlY3RzIHRoZSAnaWQnIHByb3BlcnR5IHRvIGJlIGEgc3RyaW5nLCBidXQgZ290ICR7ZXh0ZW5kZWRUeXBlb2YoXG4gICAgICAgICAgICB2YWwuaWRcbiAgICAgICAgICApfWBcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmICghdmFsLmlkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBgXCIke3ZhbC50eXBlfVwiIG1lc3NhZ2UgcmVxdWlyZXMgYSBub24tZW1wdHkgJ2lkJyBwcm9wZXJ0eWBcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmICghYXJlR3JhcGhRTEZvcm1hdHRlZEVycm9ycyh2YWwucGF5bG9hZCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGBcIiR7dmFsLnR5cGV9XCIgbWVzc2FnZSBleHBlY3RzIHRoZSAncGF5bG9hZCcgcHJvcGVydHkgdG8gYmUgYW4gYXJyYXkgb2YgR3JhcGhRTCBlcnJvcnMsIGJ1dCBnb3QgJHtKU09OLnN0cmluZ2lmeShcbiAgICAgICAgICAgIHZhbC5wYXlsb2FkXG4gICAgICAgICAgKX1gXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSBcImNvbXBsZXRlXCIgLyogQ29tcGxldGUgKi86IHtcbiAgICAgIGlmICh0eXBlb2YgdmFsLmlkICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBgXCIke3ZhbC50eXBlfVwiIG1lc3NhZ2UgZXhwZWN0cyB0aGUgJ2lkJyBwcm9wZXJ0eSB0byBiZSBhIHN0cmluZywgYnV0IGdvdCAke2V4dGVuZGVkVHlwZW9mKFxuICAgICAgICAgICAgdmFsLmlkXG4gICAgICAgICAgKX1gXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAoIXZhbC5pZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgYFwiJHt2YWwudHlwZX1cIiBtZXNzYWdlIHJlcXVpcmVzIGEgbm9uLWVtcHR5ICdpZCcgcHJvcGVydHlgXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBtZXNzYWdlICd0eXBlJyBwcm9wZXJ0eSBcIiR7dmFsLnR5cGV9XCJgKTtcbiAgfVxuICByZXR1cm4gdmFsO1xufVxuZnVuY3Rpb24gcGFyc2VNZXNzYWdlKGRhdGEsIHJldml2ZXIpIHtcbiAgcmV0dXJuIHZhbGlkYXRlTWVzc2FnZShcbiAgICB0eXBlb2YgZGF0YSA9PT0gXCJzdHJpbmdcIiA/IEpTT04ucGFyc2UoZGF0YSwgcmV2aXZlcikgOiBkYXRhXG4gICk7XG59XG5mdW5jdGlvbiBzdHJpbmdpZnlNZXNzYWdlKG1zZywgcmVwbGFjZXIpIHtcbiAgdmFsaWRhdGVNZXNzYWdlKG1zZyk7XG4gIHJldHVybiBKU09OLnN0cmluZ2lmeShtc2csIHJlcGxhY2VyKTtcbn1cblxuZXhwb3J0IHsgQ2xvc2VDb2RlIGFzIEMsIERFUFJFQ0FURURfR1JBUEhRTF9XU19QUk9UT0NPTCBhcyBELCBHUkFQSFFMX1RSQU5TUE9SVF9XU19QUk9UT0NPTCBhcyBHLCBNZXNzYWdlVHlwZSBhcyBNLCBpc0FzeW5jR2VuZXJhdG9yIGFzIGEsIGlzQXN5bmNJdGVyYWJsZSBhcyBiLCBpc09iamVjdCBhcyBpLCBsaW1pdENsb3NlUmVhc29uIGFzIGwsIHBhcnNlTWVzc2FnZSBhcyBwLCBzdHJpbmdpZnlNZXNzYWdlIGFzIHMsIHZhbGlkYXRlTWVzc2FnZSBhcyB2IH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/graphql-ws@6.0.5_graphql@16.11.0_ws@8.17.1/node_modules/graphql-ws/dist/common-CGW11Fyb.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/.pnpm/graphql-ws@6.0.5_graphql@16.11.0_ws@8.17.1/node_modules/graphql-ws/dist/client.js":
/*!**************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/graphql-ws@6.0.5_graphql@16.11.0_ws@8.17.1/node_modules/graphql-ws/dist/client.js ***!
  \**************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CloseCode: () => (/* reexport safe */ _common_CGW11Fyb_js__WEBPACK_IMPORTED_MODULE_0__.C),\n/* harmony export */   DEPRECATED_GRAPHQL_WS_PROTOCOL: () => (/* reexport safe */ _common_CGW11Fyb_js__WEBPACK_IMPORTED_MODULE_0__.D),\n/* harmony export */   GRAPHQL_TRANSPORT_WS_PROTOCOL: () => (/* reexport safe */ _common_CGW11Fyb_js__WEBPACK_IMPORTED_MODULE_0__.G),\n/* harmony export */   MessageType: () => (/* reexport safe */ _common_CGW11Fyb_js__WEBPACK_IMPORTED_MODULE_0__.M),\n/* harmony export */   TerminatedCloseEvent: () => (/* binding */ TerminatedCloseEvent),\n/* harmony export */   createClient: () => (/* binding */ createClient),\n/* harmony export */   parseMessage: () => (/* reexport safe */ _common_CGW11Fyb_js__WEBPACK_IMPORTED_MODULE_0__.p),\n/* harmony export */   stringifyMessage: () => (/* reexport safe */ _common_CGW11Fyb_js__WEBPACK_IMPORTED_MODULE_0__.s),\n/* harmony export */   validateMessage: () => (/* reexport safe */ _common_CGW11Fyb_js__WEBPACK_IMPORTED_MODULE_0__.v)\n/* harmony export */ });\n/* harmony import */ var _common_CGW11Fyb_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common-CGW11Fyb.js */ \"(action-browser)/./node_modules/.pnpm/graphql-ws@6.0.5_graphql@16.11.0_ws@8.17.1/node_modules/graphql-ws/dist/common-CGW11Fyb.js\");\n\n\n\nfunction createClient(options) {\n  const {\n    url,\n    connectionParams,\n    lazy = true,\n    onNonLazyError = console.error,\n    lazyCloseTimeout: lazyCloseTimeoutMs = 0,\n    keepAlive = 0,\n    disablePong,\n    connectionAckWaitTimeout = 0,\n    retryAttempts = 5,\n    retryWait = async function randomisedExponentialBackoff(retries2) {\n      const retryDelaySeconds = Math.pow(2, retries2);\n      await new Promise(\n        (resolve) => setTimeout(\n          resolve,\n          retryDelaySeconds * 1e3 + // add random timeout from 300ms to 3s\n          Math.floor(Math.random() * (3e3 - 300) + 300)\n        )\n      );\n    },\n    shouldRetry = isLikeCloseEvent,\n    on,\n    webSocketImpl,\n    /**\n     * Generates a v4 UUID to be used as the ID using `Math`\n     * as the random number generator. Supply your own generator\n     * in case you need more uniqueness.\n     *\n     * Reference: https://gist.github.com/jed/982883\n     */\n    generateID = function generateUUID() {\n      return \"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx\".replace(/[xy]/g, (c) => {\n        const r = Math.random() * 16 | 0, v = c == \"x\" ? r : r & 3 | 8;\n        return v.toString(16);\n      });\n    },\n    jsonMessageReplacer: replacer,\n    jsonMessageReviver: reviver\n  } = options;\n  let ws;\n  if (webSocketImpl) {\n    if (!isWebSocket(webSocketImpl)) {\n      throw new Error(\"Invalid WebSocket implementation provided\");\n    }\n    ws = webSocketImpl;\n  } else if (typeof WebSocket !== \"undefined\") {\n    ws = WebSocket;\n  } else if (typeof global !== \"undefined\") {\n    ws = global.WebSocket || // @ts-expect-error: Support more browsers\n    global.MozWebSocket;\n  } else if (typeof window !== \"undefined\") {\n    ws = window.WebSocket || // @ts-expect-error: Support more browsers\n    window.MozWebSocket;\n  }\n  if (!ws)\n    throw new Error(\n      \"WebSocket implementation missing; on Node you can `import WebSocket from 'ws';` and pass `webSocketImpl: WebSocket` to `createClient`\"\n    );\n  const WebSocketImpl = ws;\n  const emitter = (() => {\n    const message = /* @__PURE__ */ (() => {\n      const listeners2 = {};\n      return {\n        on(id, listener) {\n          listeners2[id] = listener;\n          return () => {\n            delete listeners2[id];\n          };\n        },\n        emit(message2) {\n          if (\"id\" in message2) listeners2[message2.id]?.(message2);\n        }\n      };\n    })();\n    const listeners = {\n      connecting: on?.connecting ? [on.connecting] : [],\n      opened: on?.opened ? [on.opened] : [],\n      connected: on?.connected ? [on.connected] : [],\n      ping: on?.ping ? [on.ping] : [],\n      pong: on?.pong ? [on.pong] : [],\n      message: on?.message ? [message.emit, on.message] : [message.emit],\n      closed: on?.closed ? [on.closed] : [],\n      error: on?.error ? [on.error] : []\n    };\n    return {\n      onMessage: message.on,\n      on(event, listener) {\n        const l = listeners[event];\n        l.push(listener);\n        return () => {\n          l.splice(l.indexOf(listener), 1);\n        };\n      },\n      emit(event, ...args) {\n        for (const listener of [...listeners[event]]) {\n          listener(...args);\n        }\n      }\n    };\n  })();\n  function errorOrClosed(cb) {\n    const listening = [\n      // errors are fatal and more critical than close events, throw them first\n      emitter.on(\"error\", (err) => {\n        listening.forEach((unlisten) => unlisten());\n        cb(err);\n      }),\n      // closes can be graceful and not fatal, throw them second (if error didnt throw)\n      emitter.on(\"closed\", (event) => {\n        listening.forEach((unlisten) => unlisten());\n        cb(event);\n      })\n    ];\n  }\n  let connecting, locks = 0, lazyCloseTimeout, retrying = false, retries = 0, disposed = false;\n  async function connect() {\n    clearTimeout(lazyCloseTimeout);\n    const [socket, throwOnClose] = await (connecting ?? (connecting = new Promise(\n      (connected, denied) => (async () => {\n        if (retrying) {\n          await retryWait(retries);\n          if (!locks) {\n            connecting = undefined;\n            return denied({ code: 1e3, reason: \"All Subscriptions Gone\" });\n          }\n          retries++;\n        }\n        emitter.emit(\"connecting\", retrying);\n        const socket2 = new WebSocketImpl(\n          typeof url === \"function\" ? await url() : url,\n          _common_CGW11Fyb_js__WEBPACK_IMPORTED_MODULE_0__.G\n        );\n        let connectionAckTimeout, queuedPing;\n        function enqueuePing() {\n          if (isFinite(keepAlive) && keepAlive > 0) {\n            clearTimeout(queuedPing);\n            queuedPing = setTimeout(() => {\n              if (socket2.readyState === WebSocketImpl.OPEN) {\n                socket2.send((0,_common_CGW11Fyb_js__WEBPACK_IMPORTED_MODULE_0__.s)({ type: _common_CGW11Fyb_js__WEBPACK_IMPORTED_MODULE_0__.M.Ping }));\n                emitter.emit(\"ping\", false, undefined);\n              }\n            }, keepAlive);\n          }\n        }\n        errorOrClosed((errOrEvent) => {\n          connecting = undefined;\n          clearTimeout(connectionAckTimeout);\n          clearTimeout(queuedPing);\n          denied(errOrEvent);\n          if (errOrEvent instanceof TerminatedCloseEvent) {\n            socket2.close(4499, \"Terminated\");\n            socket2.onerror = null;\n            socket2.onclose = null;\n          }\n        });\n        socket2.onerror = (err) => emitter.emit(\"error\", err);\n        socket2.onclose = (event) => emitter.emit(\"closed\", event);\n        socket2.onopen = async () => {\n          try {\n            emitter.emit(\"opened\", socket2);\n            const payload = typeof connectionParams === \"function\" ? await connectionParams() : connectionParams;\n            if (socket2.readyState !== WebSocketImpl.OPEN) return;\n            socket2.send(\n              (0,_common_CGW11Fyb_js__WEBPACK_IMPORTED_MODULE_0__.s)(\n                payload ? {\n                  type: _common_CGW11Fyb_js__WEBPACK_IMPORTED_MODULE_0__.M.ConnectionInit,\n                  payload\n                } : {\n                  type: _common_CGW11Fyb_js__WEBPACK_IMPORTED_MODULE_0__.M.ConnectionInit\n                  // payload is completely absent if not provided\n                },\n                replacer\n              )\n            );\n            if (isFinite(connectionAckWaitTimeout) && connectionAckWaitTimeout > 0) {\n              connectionAckTimeout = setTimeout(() => {\n                socket2.close(\n                  _common_CGW11Fyb_js__WEBPACK_IMPORTED_MODULE_0__.C.ConnectionAcknowledgementTimeout,\n                  \"Connection acknowledgement timeout\"\n                );\n              }, connectionAckWaitTimeout);\n            }\n            enqueuePing();\n          } catch (err) {\n            emitter.emit(\"error\", err);\n            socket2.close(\n              _common_CGW11Fyb_js__WEBPACK_IMPORTED_MODULE_0__.C.InternalClientError,\n              (0,_common_CGW11Fyb_js__WEBPACK_IMPORTED_MODULE_0__.l)(\n                err instanceof Error ? err.message : String(err),\n                \"Internal client error\"\n              )\n            );\n          }\n        };\n        let acknowledged = false;\n        socket2.onmessage = ({ data }) => {\n          try {\n            const message = (0,_common_CGW11Fyb_js__WEBPACK_IMPORTED_MODULE_0__.p)(data, reviver);\n            emitter.emit(\"message\", message);\n            if (message.type === \"ping\" || message.type === \"pong\") {\n              emitter.emit(message.type, true, message.payload);\n              if (message.type === \"pong\") {\n                enqueuePing();\n              } else if (!disablePong) {\n                socket2.send(\n                  (0,_common_CGW11Fyb_js__WEBPACK_IMPORTED_MODULE_0__.s)(\n                    message.payload ? {\n                      type: _common_CGW11Fyb_js__WEBPACK_IMPORTED_MODULE_0__.M.Pong,\n                      payload: message.payload\n                    } : {\n                      type: _common_CGW11Fyb_js__WEBPACK_IMPORTED_MODULE_0__.M.Pong\n                      // payload is completely absent if not provided\n                    }\n                  )\n                );\n                emitter.emit(\"pong\", false, message.payload);\n              }\n              return;\n            }\n            if (acknowledged) return;\n            if (message.type !== _common_CGW11Fyb_js__WEBPACK_IMPORTED_MODULE_0__.M.ConnectionAck)\n              throw new Error(\n                `First message cannot be of type ${message.type}`\n              );\n            clearTimeout(connectionAckTimeout);\n            acknowledged = true;\n            emitter.emit(\"connected\", socket2, message.payload, retrying);\n            retrying = false;\n            retries = 0;\n            connected([\n              socket2,\n              new Promise((_, reject) => errorOrClosed(reject))\n            ]);\n          } catch (err) {\n            socket2.onmessage = null;\n            emitter.emit(\"error\", err);\n            socket2.close(\n              _common_CGW11Fyb_js__WEBPACK_IMPORTED_MODULE_0__.C.BadResponse,\n              (0,_common_CGW11Fyb_js__WEBPACK_IMPORTED_MODULE_0__.l)(\n                err instanceof Error ? err.message : String(err),\n                \"Bad response\"\n              )\n            );\n          }\n        };\n      })()\n    )));\n    if (socket.readyState === WebSocketImpl.CLOSING) await throwOnClose;\n    let release = () => {\n    };\n    const released = new Promise((resolve) => release = resolve);\n    return [\n      socket,\n      release,\n      Promise.race([\n        // wait for\n        released.then(() => {\n          if (!locks) {\n            const complete = () => socket.close(1e3, \"Normal Closure\");\n            if (isFinite(lazyCloseTimeoutMs) && lazyCloseTimeoutMs > 0) {\n              lazyCloseTimeout = setTimeout(() => {\n                if (socket.readyState === WebSocketImpl.OPEN) complete();\n              }, lazyCloseTimeoutMs);\n            } else {\n              complete();\n            }\n          }\n        }),\n        // or\n        throwOnClose\n      ])\n    ];\n  }\n  function shouldRetryConnectOrThrow(errOrCloseEvent) {\n    if (isLikeCloseEvent(errOrCloseEvent) && (isFatalInternalCloseCode(errOrCloseEvent.code) || [\n      _common_CGW11Fyb_js__WEBPACK_IMPORTED_MODULE_0__.C.InternalServerError,\n      _common_CGW11Fyb_js__WEBPACK_IMPORTED_MODULE_0__.C.InternalClientError,\n      _common_CGW11Fyb_js__WEBPACK_IMPORTED_MODULE_0__.C.BadRequest,\n      _common_CGW11Fyb_js__WEBPACK_IMPORTED_MODULE_0__.C.BadResponse,\n      _common_CGW11Fyb_js__WEBPACK_IMPORTED_MODULE_0__.C.Unauthorized,\n      // CloseCode.Forbidden, might grant access out after retry\n      _common_CGW11Fyb_js__WEBPACK_IMPORTED_MODULE_0__.C.SubprotocolNotAcceptable,\n      // CloseCode.ConnectionInitialisationTimeout, might not time out after retry\n      // CloseCode.ConnectionAcknowledgementTimeout, might not time out after retry\n      _common_CGW11Fyb_js__WEBPACK_IMPORTED_MODULE_0__.C.SubscriberAlreadyExists,\n      _common_CGW11Fyb_js__WEBPACK_IMPORTED_MODULE_0__.C.TooManyInitialisationRequests\n      // 4499, // Terminated, probably because the socket froze, we want to retry\n    ].includes(errOrCloseEvent.code)))\n      throw errOrCloseEvent;\n    if (disposed) return false;\n    if (isLikeCloseEvent(errOrCloseEvent) && errOrCloseEvent.code === 1e3)\n      return locks > 0;\n    if (!retryAttempts || retries >= retryAttempts) throw errOrCloseEvent;\n    if (!shouldRetry(errOrCloseEvent)) throw errOrCloseEvent;\n    return retrying = true;\n  }\n  if (!lazy) {\n    (async () => {\n      locks++;\n      for (; ; ) {\n        try {\n          const [, , throwOnClose] = await connect();\n          await throwOnClose;\n        } catch (errOrCloseEvent) {\n          try {\n            if (!shouldRetryConnectOrThrow(errOrCloseEvent)) return;\n          } catch (errOrCloseEvent2) {\n            return onNonLazyError?.(errOrCloseEvent2);\n          }\n        }\n      }\n    })();\n  }\n  function subscribe(payload, sink) {\n    const id = generateID(payload);\n    let done = false, errored = false, releaser = () => {\n      locks--;\n      done = true;\n    };\n    (async () => {\n      locks++;\n      for (; ; ) {\n        try {\n          const [socket, release, waitForReleaseOrThrowOnClose] = await connect();\n          if (done) return release();\n          const unlisten = emitter.onMessage(id, (message) => {\n            switch (message.type) {\n              case _common_CGW11Fyb_js__WEBPACK_IMPORTED_MODULE_0__.M.Next: {\n                sink.next(message.payload);\n                return;\n              }\n              case _common_CGW11Fyb_js__WEBPACK_IMPORTED_MODULE_0__.M.Error: {\n                errored = true, done = true;\n                sink.error(message.payload);\n                releaser();\n                return;\n              }\n              case _common_CGW11Fyb_js__WEBPACK_IMPORTED_MODULE_0__.M.Complete: {\n                done = true;\n                releaser();\n                return;\n              }\n            }\n          });\n          socket.send(\n            (0,_common_CGW11Fyb_js__WEBPACK_IMPORTED_MODULE_0__.s)(\n              {\n                id,\n                type: _common_CGW11Fyb_js__WEBPACK_IMPORTED_MODULE_0__.M.Subscribe,\n                payload\n              },\n              replacer\n            )\n          );\n          releaser = () => {\n            if (!done && socket.readyState === WebSocketImpl.OPEN)\n              socket.send(\n                (0,_common_CGW11Fyb_js__WEBPACK_IMPORTED_MODULE_0__.s)(\n                  {\n                    id,\n                    type: _common_CGW11Fyb_js__WEBPACK_IMPORTED_MODULE_0__.M.Complete\n                  },\n                  replacer\n                )\n              );\n            locks--;\n            done = true;\n            release();\n          };\n          await waitForReleaseOrThrowOnClose.finally(unlisten);\n          return;\n        } catch (errOrCloseEvent) {\n          if (!shouldRetryConnectOrThrow(errOrCloseEvent)) return;\n        }\n      }\n    })().then(() => {\n      if (!errored) sink.complete();\n    }).catch((err) => {\n      sink.error(err);\n    });\n    return () => {\n      if (!done) releaser();\n    };\n  }\n  return {\n    on: emitter.on,\n    subscribe,\n    iterate(request) {\n      const pending = [];\n      const deferred = {\n        done: false,\n        error: null,\n        resolve: () => {\n        }\n      };\n      const dispose = subscribe(request, {\n        next(val) {\n          pending.push(val);\n          deferred.resolve();\n        },\n        error(err) {\n          deferred.done = true;\n          deferred.error = err;\n          deferred.resolve();\n        },\n        complete() {\n          deferred.done = true;\n          deferred.resolve();\n        }\n      });\n      const iterator = async function* iterator2() {\n        for (; ; ) {\n          if (!pending.length) {\n            await new Promise((resolve) => deferred.resolve = resolve);\n          }\n          while (pending.length) {\n            yield pending.shift();\n          }\n          if (deferred.error) {\n            throw deferred.error;\n          }\n          if (deferred.done) {\n            return;\n          }\n        }\n      }();\n      iterator.throw = async (err) => {\n        if (!deferred.done) {\n          deferred.done = true;\n          deferred.error = err;\n          deferred.resolve();\n        }\n        return { done: true, value: undefined };\n      };\n      iterator.return = async () => {\n        dispose();\n        return { done: true, value: undefined };\n      };\n      return iterator;\n    },\n    async dispose() {\n      disposed = true;\n      if (connecting) {\n        const [socket] = await connecting;\n        socket.close(1e3, \"Normal Closure\");\n      }\n    },\n    terminate() {\n      if (connecting) {\n        emitter.emit(\"closed\", new TerminatedCloseEvent());\n      }\n    }\n  };\n}\nclass TerminatedCloseEvent extends Error {\n  name = \"TerminatedCloseEvent\";\n  message = \"4499: Terminated\";\n  code = 4499;\n  reason = \"Terminated\";\n  wasClean = false;\n}\nfunction isLikeCloseEvent(val) {\n  return (0,_common_CGW11Fyb_js__WEBPACK_IMPORTED_MODULE_0__.i)(val) && \"code\" in val && \"reason\" in val;\n}\nfunction isFatalInternalCloseCode(code) {\n  if ([\n    1e3,\n    // Normal Closure is not an erroneous close code\n    1001,\n    // Going Away\n    1006,\n    // Abnormal Closure\n    1005,\n    // No Status Received\n    1012,\n    // Service Restart\n    1013,\n    // Try Again Later\n    1014\n    // Bad Gateway\n  ].includes(code))\n    return false;\n  return code >= 1e3 && code <= 1999;\n}\nfunction isWebSocket(val) {\n  return typeof val === \"function\" && \"constructor\" in val && \"CLOSED\" in val && \"CLOSING\" in val && \"CONNECTING\" in val && \"OPEN\" in val;\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9ncmFwaHFsLXdzQDYuMC41X2dyYXBocWxAMTYuMTEuMF93c0A4LjE3LjEvbm9kZV9tb2R1bGVzL2dyYXBocWwtd3MvZGlzdC9jbGllbnQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUE0TDtBQUMzRjs7QUFFakc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsNENBQTRDO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qiw2Q0FBNkM7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxrREFBNkI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsc0RBQWdCLEdBQUcsTUFBTSxrREFBVyxPQUFPO0FBQ3hFO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLHNEQUFnQjtBQUM5QjtBQUNBLHdCQUF3QixrREFBVztBQUNuQztBQUNBLGtCQUFrQjtBQUNsQix3QkFBd0Isa0RBQVc7QUFDbkM7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGtEQUFTO0FBQzNCO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsY0FBYyxrREFBUztBQUN2QixjQUFjLHNEQUFnQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixNQUFNO0FBQ3JDO0FBQ0EsNEJBQTRCLHNEQUFZO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQSxrQkFBa0Isc0RBQWdCO0FBQ2xDO0FBQ0EsNEJBQTRCLGtEQUFXO0FBQ3ZDO0FBQ0Esc0JBQXNCO0FBQ3RCLDRCQUE0QixrREFBVztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsa0RBQVc7QUFDNUM7QUFDQSxtREFBbUQsYUFBYTtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxjQUFjLGtEQUFTO0FBQ3ZCLGNBQWMsc0RBQWdCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxrREFBUztBQUNmLE1BQU0sa0RBQVM7QUFDZixNQUFNLGtEQUFTO0FBQ2YsTUFBTSxrREFBUztBQUNmLE1BQU0sa0RBQVM7QUFDZjtBQUNBLE1BQU0sa0RBQVM7QUFDZjtBQUNBO0FBQ0EsTUFBTSxrREFBUztBQUNmLE1BQU0sa0RBQVM7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixrREFBVztBQUM5QjtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsa0RBQVc7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixrREFBVztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsWUFBWSxzREFBZ0I7QUFDNUI7QUFDQTtBQUNBLHNCQUFzQixrREFBVztBQUNqQztBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isc0RBQWdCO0FBQ2hDO0FBQ0E7QUFDQSwwQkFBMEIsa0RBQVc7QUFDckMsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLHNEQUFRO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFcUkiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly91aS8uL25vZGVfbW9kdWxlcy8ucG5wbS9ncmFwaHFsLXdzQDYuMC41X2dyYXBocWxAMTYuMTEuMF93c0A4LjE3LjEvbm9kZV9tb2R1bGVzL2dyYXBocWwtd3MvZGlzdC9jbGllbnQuanM/MzBjOSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBHIGFzIEdSQVBIUUxfVFJBTlNQT1JUX1dTX1BST1RPQ09MLCBzIGFzIHN0cmluZ2lmeU1lc3NhZ2UsIE0gYXMgTWVzc2FnZVR5cGUsIEMgYXMgQ2xvc2VDb2RlLCBsIGFzIGxpbWl0Q2xvc2VSZWFzb24sIHAgYXMgcGFyc2VNZXNzYWdlLCBpIGFzIGlzT2JqZWN0IH0gZnJvbSAnLi9jb21tb24tQ0dXMTFGeWIuanMnO1xuZXhwb3J0IHsgRCBhcyBERVBSRUNBVEVEX0dSQVBIUUxfV1NfUFJPVE9DT0wsIHYgYXMgdmFsaWRhdGVNZXNzYWdlIH0gZnJvbSAnLi9jb21tb24tQ0dXMTFGeWIuanMnO1xuXG5mdW5jdGlvbiBjcmVhdGVDbGllbnQob3B0aW9ucykge1xuICBjb25zdCB7XG4gICAgdXJsLFxuICAgIGNvbm5lY3Rpb25QYXJhbXMsXG4gICAgbGF6eSA9IHRydWUsXG4gICAgb25Ob25MYXp5RXJyb3IgPSBjb25zb2xlLmVycm9yLFxuICAgIGxhenlDbG9zZVRpbWVvdXQ6IGxhenlDbG9zZVRpbWVvdXRNcyA9IDAsXG4gICAga2VlcEFsaXZlID0gMCxcbiAgICBkaXNhYmxlUG9uZyxcbiAgICBjb25uZWN0aW9uQWNrV2FpdFRpbWVvdXQgPSAwLFxuICAgIHJldHJ5QXR0ZW1wdHMgPSA1LFxuICAgIHJldHJ5V2FpdCA9IGFzeW5jIGZ1bmN0aW9uIHJhbmRvbWlzZWRFeHBvbmVudGlhbEJhY2tvZmYocmV0cmllczIpIHtcbiAgICAgIGNvbnN0IHJldHJ5RGVsYXlTZWNvbmRzID0gTWF0aC5wb3coMiwgcmV0cmllczIpO1xuICAgICAgYXdhaXQgbmV3IFByb21pc2UoXG4gICAgICAgIChyZXNvbHZlKSA9PiBzZXRUaW1lb3V0KFxuICAgICAgICAgIHJlc29sdmUsXG4gICAgICAgICAgcmV0cnlEZWxheVNlY29uZHMgKiAxZTMgKyAvLyBhZGQgcmFuZG9tIHRpbWVvdXQgZnJvbSAzMDBtcyB0byAzc1xuICAgICAgICAgIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqICgzZTMgLSAzMDApICsgMzAwKVxuICAgICAgICApXG4gICAgICApO1xuICAgIH0sXG4gICAgc2hvdWxkUmV0cnkgPSBpc0xpa2VDbG9zZUV2ZW50LFxuICAgIG9uLFxuICAgIHdlYlNvY2tldEltcGwsXG4gICAgLyoqXG4gICAgICogR2VuZXJhdGVzIGEgdjQgVVVJRCB0byBiZSB1c2VkIGFzIHRoZSBJRCB1c2luZyBgTWF0aGBcbiAgICAgKiBhcyB0aGUgcmFuZG9tIG51bWJlciBnZW5lcmF0b3IuIFN1cHBseSB5b3VyIG93biBnZW5lcmF0b3JcbiAgICAgKiBpbiBjYXNlIHlvdSBuZWVkIG1vcmUgdW5pcXVlbmVzcy5cbiAgICAgKlxuICAgICAqIFJlZmVyZW5jZTogaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vamVkLzk4Mjg4M1xuICAgICAqL1xuICAgIGdlbmVyYXRlSUQgPSBmdW5jdGlvbiBnZW5lcmF0ZVVVSUQoKSB7XG4gICAgICByZXR1cm4gXCJ4eHh4eHh4eC14eHh4LTR4eHgteXh4eC14eHh4eHh4eHh4eHhcIi5yZXBsYWNlKC9beHldL2csIChjKSA9PiB7XG4gICAgICAgIGNvbnN0IHIgPSBNYXRoLnJhbmRvbSgpICogMTYgfCAwLCB2ID0gYyA9PSBcInhcIiA/IHIgOiByICYgMyB8IDg7XG4gICAgICAgIHJldHVybiB2LnRvU3RyaW5nKDE2KTtcbiAgICAgIH0pO1xuICAgIH0sXG4gICAganNvbk1lc3NhZ2VSZXBsYWNlcjogcmVwbGFjZXIsXG4gICAganNvbk1lc3NhZ2VSZXZpdmVyOiByZXZpdmVyXG4gIH0gPSBvcHRpb25zO1xuICBsZXQgd3M7XG4gIGlmICh3ZWJTb2NrZXRJbXBsKSB7XG4gICAgaWYgKCFpc1dlYlNvY2tldCh3ZWJTb2NrZXRJbXBsKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBXZWJTb2NrZXQgaW1wbGVtZW50YXRpb24gcHJvdmlkZWRcIik7XG4gICAgfVxuICAgIHdzID0gd2ViU29ja2V0SW1wbDtcbiAgfSBlbHNlIGlmICh0eXBlb2YgV2ViU29ja2V0ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgd3MgPSBXZWJTb2NrZXQ7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHdzID0gZ2xvYmFsLldlYlNvY2tldCB8fCAvLyBAdHMtZXhwZWN0LWVycm9yOiBTdXBwb3J0IG1vcmUgYnJvd3NlcnNcbiAgICBnbG9iYWwuTW96V2ViU29ja2V0O1xuICB9IGVsc2UgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICB3cyA9IHdpbmRvdy5XZWJTb2NrZXQgfHwgLy8gQHRzLWV4cGVjdC1lcnJvcjogU3VwcG9ydCBtb3JlIGJyb3dzZXJzXG4gICAgd2luZG93Lk1veldlYlNvY2tldDtcbiAgfVxuICBpZiAoIXdzKVxuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIFwiV2ViU29ja2V0IGltcGxlbWVudGF0aW9uIG1pc3Npbmc7IG9uIE5vZGUgeW91IGNhbiBgaW1wb3J0IFdlYlNvY2tldCBmcm9tICd3cyc7YCBhbmQgcGFzcyBgd2ViU29ja2V0SW1wbDogV2ViU29ja2V0YCB0byBgY3JlYXRlQ2xpZW50YFwiXG4gICAgKTtcbiAgY29uc3QgV2ViU29ja2V0SW1wbCA9IHdzO1xuICBjb25zdCBlbWl0dGVyID0gKCgpID0+IHtcbiAgICBjb25zdCBtZXNzYWdlID0gLyogQF9fUFVSRV9fICovICgoKSA9PiB7XG4gICAgICBjb25zdCBsaXN0ZW5lcnMyID0ge307XG4gICAgICByZXR1cm4ge1xuICAgICAgICBvbihpZCwgbGlzdGVuZXIpIHtcbiAgICAgICAgICBsaXN0ZW5lcnMyW2lkXSA9IGxpc3RlbmVyO1xuICAgICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICBkZWxldGUgbGlzdGVuZXJzMltpZF07XG4gICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgZW1pdChtZXNzYWdlMikge1xuICAgICAgICAgIGlmIChcImlkXCIgaW4gbWVzc2FnZTIpIGxpc3RlbmVyczJbbWVzc2FnZTIuaWRdPy4obWVzc2FnZTIpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0pKCk7XG4gICAgY29uc3QgbGlzdGVuZXJzID0ge1xuICAgICAgY29ubmVjdGluZzogb24/LmNvbm5lY3RpbmcgPyBbb24uY29ubmVjdGluZ10gOiBbXSxcbiAgICAgIG9wZW5lZDogb24/Lm9wZW5lZCA/IFtvbi5vcGVuZWRdIDogW10sXG4gICAgICBjb25uZWN0ZWQ6IG9uPy5jb25uZWN0ZWQgPyBbb24uY29ubmVjdGVkXSA6IFtdLFxuICAgICAgcGluZzogb24/LnBpbmcgPyBbb24ucGluZ10gOiBbXSxcbiAgICAgIHBvbmc6IG9uPy5wb25nID8gW29uLnBvbmddIDogW10sXG4gICAgICBtZXNzYWdlOiBvbj8ubWVzc2FnZSA/IFttZXNzYWdlLmVtaXQsIG9uLm1lc3NhZ2VdIDogW21lc3NhZ2UuZW1pdF0sXG4gICAgICBjbG9zZWQ6IG9uPy5jbG9zZWQgPyBbb24uY2xvc2VkXSA6IFtdLFxuICAgICAgZXJyb3I6IG9uPy5lcnJvciA/IFtvbi5lcnJvcl0gOiBbXVxuICAgIH07XG4gICAgcmV0dXJuIHtcbiAgICAgIG9uTWVzc2FnZTogbWVzc2FnZS5vbixcbiAgICAgIG9uKGV2ZW50LCBsaXN0ZW5lcikge1xuICAgICAgICBjb25zdCBsID0gbGlzdGVuZXJzW2V2ZW50XTtcbiAgICAgICAgbC5wdXNoKGxpc3RlbmVyKTtcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICBsLnNwbGljZShsLmluZGV4T2YobGlzdGVuZXIpLCAxKTtcbiAgICAgICAgfTtcbiAgICAgIH0sXG4gICAgICBlbWl0KGV2ZW50LCAuLi5hcmdzKSB7XG4gICAgICAgIGZvciAoY29uc3QgbGlzdGVuZXIgb2YgWy4uLmxpc3RlbmVyc1tldmVudF1dKSB7XG4gICAgICAgICAgbGlzdGVuZXIoLi4uYXJncyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9KSgpO1xuICBmdW5jdGlvbiBlcnJvck9yQ2xvc2VkKGNiKSB7XG4gICAgY29uc3QgbGlzdGVuaW5nID0gW1xuICAgICAgLy8gZXJyb3JzIGFyZSBmYXRhbCBhbmQgbW9yZSBjcml0aWNhbCB0aGFuIGNsb3NlIGV2ZW50cywgdGhyb3cgdGhlbSBmaXJzdFxuICAgICAgZW1pdHRlci5vbihcImVycm9yXCIsIChlcnIpID0+IHtcbiAgICAgICAgbGlzdGVuaW5nLmZvckVhY2goKHVubGlzdGVuKSA9PiB1bmxpc3RlbigpKTtcbiAgICAgICAgY2IoZXJyKTtcbiAgICAgIH0pLFxuICAgICAgLy8gY2xvc2VzIGNhbiBiZSBncmFjZWZ1bCBhbmQgbm90IGZhdGFsLCB0aHJvdyB0aGVtIHNlY29uZCAoaWYgZXJyb3IgZGlkbnQgdGhyb3cpXG4gICAgICBlbWl0dGVyLm9uKFwiY2xvc2VkXCIsIChldmVudCkgPT4ge1xuICAgICAgICBsaXN0ZW5pbmcuZm9yRWFjaCgodW5saXN0ZW4pID0+IHVubGlzdGVuKCkpO1xuICAgICAgICBjYihldmVudCk7XG4gICAgICB9KVxuICAgIF07XG4gIH1cbiAgbGV0IGNvbm5lY3RpbmcsIGxvY2tzID0gMCwgbGF6eUNsb3NlVGltZW91dCwgcmV0cnlpbmcgPSBmYWxzZSwgcmV0cmllcyA9IDAsIGRpc3Bvc2VkID0gZmFsc2U7XG4gIGFzeW5jIGZ1bmN0aW9uIGNvbm5lY3QoKSB7XG4gICAgY2xlYXJUaW1lb3V0KGxhenlDbG9zZVRpbWVvdXQpO1xuICAgIGNvbnN0IFtzb2NrZXQsIHRocm93T25DbG9zZV0gPSBhd2FpdCAoY29ubmVjdGluZyA/PyAoY29ubmVjdGluZyA9IG5ldyBQcm9taXNlKFxuICAgICAgKGNvbm5lY3RlZCwgZGVuaWVkKSA9PiAoYXN5bmMgKCkgPT4ge1xuICAgICAgICBpZiAocmV0cnlpbmcpIHtcbiAgICAgICAgICBhd2FpdCByZXRyeVdhaXQocmV0cmllcyk7XG4gICAgICAgICAgaWYgKCFsb2Nrcykge1xuICAgICAgICAgICAgY29ubmVjdGluZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHJldHVybiBkZW5pZWQoeyBjb2RlOiAxZTMsIHJlYXNvbjogXCJBbGwgU3Vic2NyaXB0aW9ucyBHb25lXCIgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHJpZXMrKztcbiAgICAgICAgfVxuICAgICAgICBlbWl0dGVyLmVtaXQoXCJjb25uZWN0aW5nXCIsIHJldHJ5aW5nKTtcbiAgICAgICAgY29uc3Qgc29ja2V0MiA9IG5ldyBXZWJTb2NrZXRJbXBsKFxuICAgICAgICAgIHR5cGVvZiB1cmwgPT09IFwiZnVuY3Rpb25cIiA/IGF3YWl0IHVybCgpIDogdXJsLFxuICAgICAgICAgIEdSQVBIUUxfVFJBTlNQT1JUX1dTX1BST1RPQ09MXG4gICAgICAgICk7XG4gICAgICAgIGxldCBjb25uZWN0aW9uQWNrVGltZW91dCwgcXVldWVkUGluZztcbiAgICAgICAgZnVuY3Rpb24gZW5xdWV1ZVBpbmcoKSB7XG4gICAgICAgICAgaWYgKGlzRmluaXRlKGtlZXBBbGl2ZSkgJiYga2VlcEFsaXZlID4gMCkge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHF1ZXVlZFBpbmcpO1xuICAgICAgICAgICAgcXVldWVkUGluZyA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICBpZiAoc29ja2V0Mi5yZWFkeVN0YXRlID09PSBXZWJTb2NrZXRJbXBsLk9QRU4pIHtcbiAgICAgICAgICAgICAgICBzb2NrZXQyLnNlbmQoc3RyaW5naWZ5TWVzc2FnZSh7IHR5cGU6IE1lc3NhZ2VUeXBlLlBpbmcgfSkpO1xuICAgICAgICAgICAgICAgIGVtaXR0ZXIuZW1pdChcInBpbmdcIiwgZmFsc2UsIHVuZGVmaW5lZCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIGtlZXBBbGl2ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVycm9yT3JDbG9zZWQoKGVyck9yRXZlbnQpID0+IHtcbiAgICAgICAgICBjb25uZWN0aW5nID0gdW5kZWZpbmVkO1xuICAgICAgICAgIGNsZWFyVGltZW91dChjb25uZWN0aW9uQWNrVGltZW91dCk7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHF1ZXVlZFBpbmcpO1xuICAgICAgICAgIGRlbmllZChlcnJPckV2ZW50KTtcbiAgICAgICAgICBpZiAoZXJyT3JFdmVudCBpbnN0YW5jZW9mIFRlcm1pbmF0ZWRDbG9zZUV2ZW50KSB7XG4gICAgICAgICAgICBzb2NrZXQyLmNsb3NlKDQ0OTksIFwiVGVybWluYXRlZFwiKTtcbiAgICAgICAgICAgIHNvY2tldDIub25lcnJvciA9IG51bGw7XG4gICAgICAgICAgICBzb2NrZXQyLm9uY2xvc2UgPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHNvY2tldDIub25lcnJvciA9IChlcnIpID0+IGVtaXR0ZXIuZW1pdChcImVycm9yXCIsIGVycik7XG4gICAgICAgIHNvY2tldDIub25jbG9zZSA9IChldmVudCkgPT4gZW1pdHRlci5lbWl0KFwiY2xvc2VkXCIsIGV2ZW50KTtcbiAgICAgICAgc29ja2V0Mi5vbm9wZW4gPSBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGVtaXR0ZXIuZW1pdChcIm9wZW5lZFwiLCBzb2NrZXQyKTtcbiAgICAgICAgICAgIGNvbnN0IHBheWxvYWQgPSB0eXBlb2YgY29ubmVjdGlvblBhcmFtcyA9PT0gXCJmdW5jdGlvblwiID8gYXdhaXQgY29ubmVjdGlvblBhcmFtcygpIDogY29ubmVjdGlvblBhcmFtcztcbiAgICAgICAgICAgIGlmIChzb2NrZXQyLnJlYWR5U3RhdGUgIT09IFdlYlNvY2tldEltcGwuT1BFTikgcmV0dXJuO1xuICAgICAgICAgICAgc29ja2V0Mi5zZW5kKFxuICAgICAgICAgICAgICBzdHJpbmdpZnlNZXNzYWdlKFxuICAgICAgICAgICAgICAgIHBheWxvYWQgPyB7XG4gICAgICAgICAgICAgICAgICB0eXBlOiBNZXNzYWdlVHlwZS5Db25uZWN0aW9uSW5pdCxcbiAgICAgICAgICAgICAgICAgIHBheWxvYWRcbiAgICAgICAgICAgICAgICB9IDoge1xuICAgICAgICAgICAgICAgICAgdHlwZTogTWVzc2FnZVR5cGUuQ29ubmVjdGlvbkluaXRcbiAgICAgICAgICAgICAgICAgIC8vIHBheWxvYWQgaXMgY29tcGxldGVseSBhYnNlbnQgaWYgbm90IHByb3ZpZGVkXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICByZXBsYWNlclxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgaWYgKGlzRmluaXRlKGNvbm5lY3Rpb25BY2tXYWl0VGltZW91dCkgJiYgY29ubmVjdGlvbkFja1dhaXRUaW1lb3V0ID4gMCkge1xuICAgICAgICAgICAgICBjb25uZWN0aW9uQWNrVGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHNvY2tldDIuY2xvc2UoXG4gICAgICAgICAgICAgICAgICBDbG9zZUNvZGUuQ29ubmVjdGlvbkFja25vd2xlZGdlbWVudFRpbWVvdXQsXG4gICAgICAgICAgICAgICAgICBcIkNvbm5lY3Rpb24gYWNrbm93bGVkZ2VtZW50IHRpbWVvdXRcIlxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIH0sIGNvbm5lY3Rpb25BY2tXYWl0VGltZW91dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbnF1ZXVlUGluZygpO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgZW1pdHRlci5lbWl0KFwiZXJyb3JcIiwgZXJyKTtcbiAgICAgICAgICAgIHNvY2tldDIuY2xvc2UoXG4gICAgICAgICAgICAgIENsb3NlQ29kZS5JbnRlcm5hbENsaWVudEVycm9yLFxuICAgICAgICAgICAgICBsaW1pdENsb3NlUmVhc29uKFxuICAgICAgICAgICAgICAgIGVyciBpbnN0YW5jZW9mIEVycm9yID8gZXJyLm1lc3NhZ2UgOiBTdHJpbmcoZXJyKSxcbiAgICAgICAgICAgICAgICBcIkludGVybmFsIGNsaWVudCBlcnJvclwiXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBsZXQgYWNrbm93bGVkZ2VkID0gZmFsc2U7XG4gICAgICAgIHNvY2tldDIub25tZXNzYWdlID0gKHsgZGF0YSB9KSA9PiB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBwYXJzZU1lc3NhZ2UoZGF0YSwgcmV2aXZlcik7XG4gICAgICAgICAgICBlbWl0dGVyLmVtaXQoXCJtZXNzYWdlXCIsIG1lc3NhZ2UpO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UudHlwZSA9PT0gXCJwaW5nXCIgfHwgbWVzc2FnZS50eXBlID09PSBcInBvbmdcIikge1xuICAgICAgICAgICAgICBlbWl0dGVyLmVtaXQobWVzc2FnZS50eXBlLCB0cnVlLCBtZXNzYWdlLnBheWxvYWQpO1xuICAgICAgICAgICAgICBpZiAobWVzc2FnZS50eXBlID09PSBcInBvbmdcIikge1xuICAgICAgICAgICAgICAgIGVucXVldWVQaW5nKCk7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoIWRpc2FibGVQb25nKSB7XG4gICAgICAgICAgICAgICAgc29ja2V0Mi5zZW5kKFxuICAgICAgICAgICAgICAgICAgc3RyaW5naWZ5TWVzc2FnZShcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5wYXlsb2FkID8ge1xuICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IE1lc3NhZ2VUeXBlLlBvbmcsXG4gICAgICAgICAgICAgICAgICAgICAgcGF5bG9hZDogbWVzc2FnZS5wYXlsb2FkXG4gICAgICAgICAgICAgICAgICAgIH0gOiB7XG4gICAgICAgICAgICAgICAgICAgICAgdHlwZTogTWVzc2FnZVR5cGUuUG9uZ1xuICAgICAgICAgICAgICAgICAgICAgIC8vIHBheWxvYWQgaXMgY29tcGxldGVseSBhYnNlbnQgaWYgbm90IHByb3ZpZGVkXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGVtaXR0ZXIuZW1pdChcInBvbmdcIiwgZmFsc2UsIG1lc3NhZ2UucGF5bG9hZCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGFja25vd2xlZGdlZCkgcmV0dXJuO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UudHlwZSAhPT0gTWVzc2FnZVR5cGUuQ29ubmVjdGlvbkFjaylcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgIGBGaXJzdCBtZXNzYWdlIGNhbm5vdCBiZSBvZiB0eXBlICR7bWVzc2FnZS50eXBlfWBcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dChjb25uZWN0aW9uQWNrVGltZW91dCk7XG4gICAgICAgICAgICBhY2tub3dsZWRnZWQgPSB0cnVlO1xuICAgICAgICAgICAgZW1pdHRlci5lbWl0KFwiY29ubmVjdGVkXCIsIHNvY2tldDIsIG1lc3NhZ2UucGF5bG9hZCwgcmV0cnlpbmcpO1xuICAgICAgICAgICAgcmV0cnlpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIHJldHJpZXMgPSAwO1xuICAgICAgICAgICAgY29ubmVjdGVkKFtcbiAgICAgICAgICAgICAgc29ja2V0MixcbiAgICAgICAgICAgICAgbmV3IFByb21pc2UoKF8sIHJlamVjdCkgPT4gZXJyb3JPckNsb3NlZChyZWplY3QpKVxuICAgICAgICAgICAgXSk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBzb2NrZXQyLm9ubWVzc2FnZSA9IG51bGw7XG4gICAgICAgICAgICBlbWl0dGVyLmVtaXQoXCJlcnJvclwiLCBlcnIpO1xuICAgICAgICAgICAgc29ja2V0Mi5jbG9zZShcbiAgICAgICAgICAgICAgQ2xvc2VDb2RlLkJhZFJlc3BvbnNlLFxuICAgICAgICAgICAgICBsaW1pdENsb3NlUmVhc29uKFxuICAgICAgICAgICAgICAgIGVyciBpbnN0YW5jZW9mIEVycm9yID8gZXJyLm1lc3NhZ2UgOiBTdHJpbmcoZXJyKSxcbiAgICAgICAgICAgICAgICBcIkJhZCByZXNwb25zZVwiXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfSkoKVxuICAgICkpKTtcbiAgICBpZiAoc29ja2V0LnJlYWR5U3RhdGUgPT09IFdlYlNvY2tldEltcGwuQ0xPU0lORykgYXdhaXQgdGhyb3dPbkNsb3NlO1xuICAgIGxldCByZWxlYXNlID0gKCkgPT4ge1xuICAgIH07XG4gICAgY29uc3QgcmVsZWFzZWQgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gcmVsZWFzZSA9IHJlc29sdmUpO1xuICAgIHJldHVybiBbXG4gICAgICBzb2NrZXQsXG4gICAgICByZWxlYXNlLFxuICAgICAgUHJvbWlzZS5yYWNlKFtcbiAgICAgICAgLy8gd2FpdCBmb3JcbiAgICAgICAgcmVsZWFzZWQudGhlbigoKSA9PiB7XG4gICAgICAgICAgaWYgKCFsb2Nrcykge1xuICAgICAgICAgICAgY29uc3QgY29tcGxldGUgPSAoKSA9PiBzb2NrZXQuY2xvc2UoMWUzLCBcIk5vcm1hbCBDbG9zdXJlXCIpO1xuICAgICAgICAgICAgaWYgKGlzRmluaXRlKGxhenlDbG9zZVRpbWVvdXRNcykgJiYgbGF6eUNsb3NlVGltZW91dE1zID4gMCkge1xuICAgICAgICAgICAgICBsYXp5Q2xvc2VUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHNvY2tldC5yZWFkeVN0YXRlID09PSBXZWJTb2NrZXRJbXBsLk9QRU4pIGNvbXBsZXRlKCk7XG4gICAgICAgICAgICAgIH0sIGxhenlDbG9zZVRpbWVvdXRNcyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjb21wbGV0ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSksXG4gICAgICAgIC8vIG9yXG4gICAgICAgIHRocm93T25DbG9zZVxuICAgICAgXSlcbiAgICBdO1xuICB9XG4gIGZ1bmN0aW9uIHNob3VsZFJldHJ5Q29ubmVjdE9yVGhyb3coZXJyT3JDbG9zZUV2ZW50KSB7XG4gICAgaWYgKGlzTGlrZUNsb3NlRXZlbnQoZXJyT3JDbG9zZUV2ZW50KSAmJiAoaXNGYXRhbEludGVybmFsQ2xvc2VDb2RlKGVyck9yQ2xvc2VFdmVudC5jb2RlKSB8fCBbXG4gICAgICBDbG9zZUNvZGUuSW50ZXJuYWxTZXJ2ZXJFcnJvcixcbiAgICAgIENsb3NlQ29kZS5JbnRlcm5hbENsaWVudEVycm9yLFxuICAgICAgQ2xvc2VDb2RlLkJhZFJlcXVlc3QsXG4gICAgICBDbG9zZUNvZGUuQmFkUmVzcG9uc2UsXG4gICAgICBDbG9zZUNvZGUuVW5hdXRob3JpemVkLFxuICAgICAgLy8gQ2xvc2VDb2RlLkZvcmJpZGRlbiwgbWlnaHQgZ3JhbnQgYWNjZXNzIG91dCBhZnRlciByZXRyeVxuICAgICAgQ2xvc2VDb2RlLlN1YnByb3RvY29sTm90QWNjZXB0YWJsZSxcbiAgICAgIC8vIENsb3NlQ29kZS5Db25uZWN0aW9uSW5pdGlhbGlzYXRpb25UaW1lb3V0LCBtaWdodCBub3QgdGltZSBvdXQgYWZ0ZXIgcmV0cnlcbiAgICAgIC8vIENsb3NlQ29kZS5Db25uZWN0aW9uQWNrbm93bGVkZ2VtZW50VGltZW91dCwgbWlnaHQgbm90IHRpbWUgb3V0IGFmdGVyIHJldHJ5XG4gICAgICBDbG9zZUNvZGUuU3Vic2NyaWJlckFscmVhZHlFeGlzdHMsXG4gICAgICBDbG9zZUNvZGUuVG9vTWFueUluaXRpYWxpc2F0aW9uUmVxdWVzdHNcbiAgICAgIC8vIDQ0OTksIC8vIFRlcm1pbmF0ZWQsIHByb2JhYmx5IGJlY2F1c2UgdGhlIHNvY2tldCBmcm96ZSwgd2Ugd2FudCB0byByZXRyeVxuICAgIF0uaW5jbHVkZXMoZXJyT3JDbG9zZUV2ZW50LmNvZGUpKSlcbiAgICAgIHRocm93IGVyck9yQ2xvc2VFdmVudDtcbiAgICBpZiAoZGlzcG9zZWQpIHJldHVybiBmYWxzZTtcbiAgICBpZiAoaXNMaWtlQ2xvc2VFdmVudChlcnJPckNsb3NlRXZlbnQpICYmIGVyck9yQ2xvc2VFdmVudC5jb2RlID09PSAxZTMpXG4gICAgICByZXR1cm4gbG9ja3MgPiAwO1xuICAgIGlmICghcmV0cnlBdHRlbXB0cyB8fCByZXRyaWVzID49IHJldHJ5QXR0ZW1wdHMpIHRocm93IGVyck9yQ2xvc2VFdmVudDtcbiAgICBpZiAoIXNob3VsZFJldHJ5KGVyck9yQ2xvc2VFdmVudCkpIHRocm93IGVyck9yQ2xvc2VFdmVudDtcbiAgICByZXR1cm4gcmV0cnlpbmcgPSB0cnVlO1xuICB9XG4gIGlmICghbGF6eSkge1xuICAgIChhc3luYyAoKSA9PiB7XG4gICAgICBsb2NrcysrO1xuICAgICAgZm9yICg7IDsgKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgWywgLCB0aHJvd09uQ2xvc2VdID0gYXdhaXQgY29ubmVjdCgpO1xuICAgICAgICAgIGF3YWl0IHRocm93T25DbG9zZTtcbiAgICAgICAgfSBjYXRjaCAoZXJyT3JDbG9zZUV2ZW50KSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICghc2hvdWxkUmV0cnlDb25uZWN0T3JUaHJvdyhlcnJPckNsb3NlRXZlbnQpKSByZXR1cm47XG4gICAgICAgICAgfSBjYXRjaCAoZXJyT3JDbG9zZUV2ZW50Mikge1xuICAgICAgICAgICAgcmV0dXJuIG9uTm9uTGF6eUVycm9yPy4oZXJyT3JDbG9zZUV2ZW50Mik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSkoKTtcbiAgfVxuICBmdW5jdGlvbiBzdWJzY3JpYmUocGF5bG9hZCwgc2luaykge1xuICAgIGNvbnN0IGlkID0gZ2VuZXJhdGVJRChwYXlsb2FkKTtcbiAgICBsZXQgZG9uZSA9IGZhbHNlLCBlcnJvcmVkID0gZmFsc2UsIHJlbGVhc2VyID0gKCkgPT4ge1xuICAgICAgbG9ja3MtLTtcbiAgICAgIGRvbmUgPSB0cnVlO1xuICAgIH07XG4gICAgKGFzeW5jICgpID0+IHtcbiAgICAgIGxvY2tzKys7XG4gICAgICBmb3IgKDsgOyApIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCBbc29ja2V0LCByZWxlYXNlLCB3YWl0Rm9yUmVsZWFzZU9yVGhyb3dPbkNsb3NlXSA9IGF3YWl0IGNvbm5lY3QoKTtcbiAgICAgICAgICBpZiAoZG9uZSkgcmV0dXJuIHJlbGVhc2UoKTtcbiAgICAgICAgICBjb25zdCB1bmxpc3RlbiA9IGVtaXR0ZXIub25NZXNzYWdlKGlkLCAobWVzc2FnZSkgPT4ge1xuICAgICAgICAgICAgc3dpdGNoIChtZXNzYWdlLnR5cGUpIHtcbiAgICAgICAgICAgICAgY2FzZSBNZXNzYWdlVHlwZS5OZXh0OiB7XG4gICAgICAgICAgICAgICAgc2luay5uZXh0KG1lc3NhZ2UucGF5bG9hZCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNhc2UgTWVzc2FnZVR5cGUuRXJyb3I6IHtcbiAgICAgICAgICAgICAgICBlcnJvcmVkID0gdHJ1ZSwgZG9uZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgc2luay5lcnJvcihtZXNzYWdlLnBheWxvYWQpO1xuICAgICAgICAgICAgICAgIHJlbGVhc2VyKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNhc2UgTWVzc2FnZVR5cGUuQ29tcGxldGU6IHtcbiAgICAgICAgICAgICAgICBkb25lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICByZWxlYXNlcigpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHNvY2tldC5zZW5kKFxuICAgICAgICAgICAgc3RyaW5naWZ5TWVzc2FnZShcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgICAgIHR5cGU6IE1lc3NhZ2VUeXBlLlN1YnNjcmliZSxcbiAgICAgICAgICAgICAgICBwYXlsb2FkXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHJlcGxhY2VyXG4gICAgICAgICAgICApXG4gICAgICAgICAgKTtcbiAgICAgICAgICByZWxlYXNlciA9ICgpID0+IHtcbiAgICAgICAgICAgIGlmICghZG9uZSAmJiBzb2NrZXQucmVhZHlTdGF0ZSA9PT0gV2ViU29ja2V0SW1wbC5PUEVOKVxuICAgICAgICAgICAgICBzb2NrZXQuc2VuZChcbiAgICAgICAgICAgICAgICBzdHJpbmdpZnlNZXNzYWdlKFxuICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBpZCxcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogTWVzc2FnZVR5cGUuQ29tcGxldGVcbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICByZXBsYWNlclxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGxvY2tzLS07XG4gICAgICAgICAgICBkb25lID0gdHJ1ZTtcbiAgICAgICAgICAgIHJlbGVhc2UoKTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIGF3YWl0IHdhaXRGb3JSZWxlYXNlT3JUaHJvd09uQ2xvc2UuZmluYWxseSh1bmxpc3Rlbik7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IGNhdGNoIChlcnJPckNsb3NlRXZlbnQpIHtcbiAgICAgICAgICBpZiAoIXNob3VsZFJldHJ5Q29ubmVjdE9yVGhyb3coZXJyT3JDbG9zZUV2ZW50KSkgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSkoKS50aGVuKCgpID0+IHtcbiAgICAgIGlmICghZXJyb3JlZCkgc2luay5jb21wbGV0ZSgpO1xuICAgIH0pLmNhdGNoKChlcnIpID0+IHtcbiAgICAgIHNpbmsuZXJyb3IoZXJyKTtcbiAgICB9KTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgaWYgKCFkb25lKSByZWxlYXNlcigpO1xuICAgIH07XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBvbjogZW1pdHRlci5vbixcbiAgICBzdWJzY3JpYmUsXG4gICAgaXRlcmF0ZShyZXF1ZXN0KSB7XG4gICAgICBjb25zdCBwZW5kaW5nID0gW107XG4gICAgICBjb25zdCBkZWZlcnJlZCA9IHtcbiAgICAgICAgZG9uZTogZmFsc2UsXG4gICAgICAgIGVycm9yOiBudWxsLFxuICAgICAgICByZXNvbHZlOiAoKSA9PiB7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBjb25zdCBkaXNwb3NlID0gc3Vic2NyaWJlKHJlcXVlc3QsIHtcbiAgICAgICAgbmV4dCh2YWwpIHtcbiAgICAgICAgICBwZW5kaW5nLnB1c2godmFsKTtcbiAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKCk7XG4gICAgICAgIH0sXG4gICAgICAgIGVycm9yKGVycikge1xuICAgICAgICAgIGRlZmVycmVkLmRvbmUgPSB0cnVlO1xuICAgICAgICAgIGRlZmVycmVkLmVycm9yID0gZXJyO1xuICAgICAgICAgIGRlZmVycmVkLnJlc29sdmUoKTtcbiAgICAgICAgfSxcbiAgICAgICAgY29tcGxldGUoKSB7XG4gICAgICAgICAgZGVmZXJyZWQuZG9uZSA9IHRydWU7XG4gICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZSgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGNvbnN0IGl0ZXJhdG9yID0gYXN5bmMgZnVuY3Rpb24qIGl0ZXJhdG9yMigpIHtcbiAgICAgICAgZm9yICg7IDsgKSB7XG4gICAgICAgICAgaWYgKCFwZW5kaW5nLmxlbmd0aCkge1xuICAgICAgICAgICAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUpID0+IGRlZmVycmVkLnJlc29sdmUgPSByZXNvbHZlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgd2hpbGUgKHBlbmRpbmcubGVuZ3RoKSB7XG4gICAgICAgICAgICB5aWVsZCBwZW5kaW5nLnNoaWZ0KCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChkZWZlcnJlZC5lcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgZGVmZXJyZWQuZXJyb3I7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChkZWZlcnJlZC5kb25lKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KCk7XG4gICAgICBpdGVyYXRvci50aHJvdyA9IGFzeW5jIChlcnIpID0+IHtcbiAgICAgICAgaWYgKCFkZWZlcnJlZC5kb25lKSB7XG4gICAgICAgICAgZGVmZXJyZWQuZG9uZSA9IHRydWU7XG4gICAgICAgICAgZGVmZXJyZWQuZXJyb3IgPSBlcnI7XG4gICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGRvbmU6IHRydWUsIHZhbHVlOiB1bmRlZmluZWQgfTtcbiAgICAgIH07XG4gICAgICBpdGVyYXRvci5yZXR1cm4gPSBhc3luYyAoKSA9PiB7XG4gICAgICAgIGRpc3Bvc2UoKTtcbiAgICAgICAgcmV0dXJuIHsgZG9uZTogdHJ1ZSwgdmFsdWU6IHVuZGVmaW5lZCB9O1xuICAgICAgfTtcbiAgICAgIHJldHVybiBpdGVyYXRvcjtcbiAgICB9LFxuICAgIGFzeW5jIGRpc3Bvc2UoKSB7XG4gICAgICBkaXNwb3NlZCA9IHRydWU7XG4gICAgICBpZiAoY29ubmVjdGluZykge1xuICAgICAgICBjb25zdCBbc29ja2V0XSA9IGF3YWl0IGNvbm5lY3Rpbmc7XG4gICAgICAgIHNvY2tldC5jbG9zZSgxZTMsIFwiTm9ybWFsIENsb3N1cmVcIik7XG4gICAgICB9XG4gICAgfSxcbiAgICB0ZXJtaW5hdGUoKSB7XG4gICAgICBpZiAoY29ubmVjdGluZykge1xuICAgICAgICBlbWl0dGVyLmVtaXQoXCJjbG9zZWRcIiwgbmV3IFRlcm1pbmF0ZWRDbG9zZUV2ZW50KCkpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbn1cbmNsYXNzIFRlcm1pbmF0ZWRDbG9zZUV2ZW50IGV4dGVuZHMgRXJyb3Ige1xuICBuYW1lID0gXCJUZXJtaW5hdGVkQ2xvc2VFdmVudFwiO1xuICBtZXNzYWdlID0gXCI0NDk5OiBUZXJtaW5hdGVkXCI7XG4gIGNvZGUgPSA0NDk5O1xuICByZWFzb24gPSBcIlRlcm1pbmF0ZWRcIjtcbiAgd2FzQ2xlYW4gPSBmYWxzZTtcbn1cbmZ1bmN0aW9uIGlzTGlrZUNsb3NlRXZlbnQodmFsKSB7XG4gIHJldHVybiBpc09iamVjdCh2YWwpICYmIFwiY29kZVwiIGluIHZhbCAmJiBcInJlYXNvblwiIGluIHZhbDtcbn1cbmZ1bmN0aW9uIGlzRmF0YWxJbnRlcm5hbENsb3NlQ29kZShjb2RlKSB7XG4gIGlmIChbXG4gICAgMWUzLFxuICAgIC8vIE5vcm1hbCBDbG9zdXJlIGlzIG5vdCBhbiBlcnJvbmVvdXMgY2xvc2UgY29kZVxuICAgIDEwMDEsXG4gICAgLy8gR29pbmcgQXdheVxuICAgIDEwMDYsXG4gICAgLy8gQWJub3JtYWwgQ2xvc3VyZVxuICAgIDEwMDUsXG4gICAgLy8gTm8gU3RhdHVzIFJlY2VpdmVkXG4gICAgMTAxMixcbiAgICAvLyBTZXJ2aWNlIFJlc3RhcnRcbiAgICAxMDEzLFxuICAgIC8vIFRyeSBBZ2FpbiBMYXRlclxuICAgIDEwMTRcbiAgICAvLyBCYWQgR2F0ZXdheVxuICBdLmluY2x1ZGVzKGNvZGUpKVxuICAgIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIGNvZGUgPj0gMWUzICYmIGNvZGUgPD0gMTk5OTtcbn1cbmZ1bmN0aW9uIGlzV2ViU29ja2V0KHZhbCkge1xuICByZXR1cm4gdHlwZW9mIHZhbCA9PT0gXCJmdW5jdGlvblwiICYmIFwiY29uc3RydWN0b3JcIiBpbiB2YWwgJiYgXCJDTE9TRURcIiBpbiB2YWwgJiYgXCJDTE9TSU5HXCIgaW4gdmFsICYmIFwiQ09OTkVDVElOR1wiIGluIHZhbCAmJiBcIk9QRU5cIiBpbiB2YWw7XG59XG5cbmV4cG9ydCB7IENsb3NlQ29kZSwgR1JBUEhRTF9UUkFOU1BPUlRfV1NfUFJPVE9DT0wsIE1lc3NhZ2VUeXBlLCBUZXJtaW5hdGVkQ2xvc2VFdmVudCwgY3JlYXRlQ2xpZW50LCBwYXJzZU1lc3NhZ2UsIHN0cmluZ2lmeU1lc3NhZ2UgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/.pnpm/graphql-ws@6.0.5_graphql@16.11.0_ws@8.17.1/node_modules/graphql-ws/dist/client.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/.pnpm/graphql-ws@6.0.5_graphql@16.11.0_ws@8.17.1/node_modules/graphql-ws/dist/common-CGW11Fyb.js":
/*!***********************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/graphql-ws@6.0.5_graphql@16.11.0_ws@8.17.1/node_modules/graphql-ws/dist/common-CGW11Fyb.js ***!
  \***********************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   C: () => (/* binding */ CloseCode),\n/* harmony export */   D: () => (/* binding */ DEPRECATED_GRAPHQL_WS_PROTOCOL),\n/* harmony export */   G: () => (/* binding */ GRAPHQL_TRANSPORT_WS_PROTOCOL),\n/* harmony export */   M: () => (/* binding */ MessageType),\n/* harmony export */   a: () => (/* binding */ isAsyncGenerator),\n/* harmony export */   b: () => (/* binding */ isAsyncIterable),\n/* harmony export */   i: () => (/* binding */ isObject),\n/* harmony export */   l: () => (/* binding */ limitCloseReason),\n/* harmony export */   p: () => (/* binding */ parseMessage),\n/* harmony export */   s: () => (/* binding */ stringifyMessage),\n/* harmony export */   v: () => (/* binding */ validateMessage)\n/* harmony export */ });\nfunction extendedTypeof(val) {\n  if (val === null) {\n    return \"null\";\n  }\n  if (Array.isArray(val)) {\n    return \"array\";\n  }\n  return typeof val;\n}\nfunction isObject(val) {\n  return extendedTypeof(val) === \"object\";\n}\nfunction isAsyncIterable(val) {\n  return typeof Object(val)[Symbol.asyncIterator] === \"function\";\n}\nfunction isAsyncGenerator(val) {\n  return isObject(val) && typeof Object(val)[Symbol.asyncIterator] === \"function\" && typeof val.return === \"function\";\n}\nfunction areGraphQLFormattedErrors(obj) {\n  return Array.isArray(obj) && // must be at least one error\n  obj.length > 0 && // error has at least a message\n  obj.every((ob) => \"message\" in ob);\n}\nfunction limitCloseReason(reason, whenTooLong) {\n  return reason.length < 124 ? reason : whenTooLong;\n}\n\nconst GRAPHQL_TRANSPORT_WS_PROTOCOL = \"graphql-transport-ws\";\nconst DEPRECATED_GRAPHQL_WS_PROTOCOL = \"graphql-ws\";\nvar CloseCode = /* @__PURE__ */ ((CloseCode2) => {\n  CloseCode2[CloseCode2[\"InternalServerError\"] = 4500] = \"InternalServerError\";\n  CloseCode2[CloseCode2[\"InternalClientError\"] = 4005] = \"InternalClientError\";\n  CloseCode2[CloseCode2[\"BadRequest\"] = 4400] = \"BadRequest\";\n  CloseCode2[CloseCode2[\"BadResponse\"] = 4004] = \"BadResponse\";\n  CloseCode2[CloseCode2[\"Unauthorized\"] = 4401] = \"Unauthorized\";\n  CloseCode2[CloseCode2[\"Forbidden\"] = 4403] = \"Forbidden\";\n  CloseCode2[CloseCode2[\"SubprotocolNotAcceptable\"] = 4406] = \"SubprotocolNotAcceptable\";\n  CloseCode2[CloseCode2[\"ConnectionInitialisationTimeout\"] = 4408] = \"ConnectionInitialisationTimeout\";\n  CloseCode2[CloseCode2[\"ConnectionAcknowledgementTimeout\"] = 4504] = \"ConnectionAcknowledgementTimeout\";\n  CloseCode2[CloseCode2[\"SubscriberAlreadyExists\"] = 4409] = \"SubscriberAlreadyExists\";\n  CloseCode2[CloseCode2[\"TooManyInitialisationRequests\"] = 4429] = \"TooManyInitialisationRequests\";\n  return CloseCode2;\n})(CloseCode || {});\nvar MessageType = /* @__PURE__ */ ((MessageType2) => {\n  MessageType2[\"ConnectionInit\"] = \"connection_init\";\n  MessageType2[\"ConnectionAck\"] = \"connection_ack\";\n  MessageType2[\"Ping\"] = \"ping\";\n  MessageType2[\"Pong\"] = \"pong\";\n  MessageType2[\"Subscribe\"] = \"subscribe\";\n  MessageType2[\"Next\"] = \"next\";\n  MessageType2[\"Error\"] = \"error\";\n  MessageType2[\"Complete\"] = \"complete\";\n  return MessageType2;\n})(MessageType || {});\nfunction validateMessage(val) {\n  if (!isObject(val)) {\n    throw new Error(\n      `Message is expected to be an object, but got ${extendedTypeof(val)}`\n    );\n  }\n  if (!val.type) {\n    throw new Error(`Message is missing the 'type' property`);\n  }\n  if (typeof val.type !== \"string\") {\n    throw new Error(\n      `Message is expects the 'type' property to be a string, but got ${extendedTypeof(\n        val.type\n      )}`\n    );\n  }\n  switch (val.type) {\n    case \"connection_init\" /* ConnectionInit */:\n    case \"connection_ack\" /* ConnectionAck */:\n    case \"ping\" /* Ping */:\n    case \"pong\" /* Pong */: {\n      if (val.payload != null && !isObject(val.payload)) {\n        throw new Error(\n          `\"${val.type}\" message expects the 'payload' property to be an object or nullish or missing, but got \"${val.payload}\"`\n        );\n      }\n      break;\n    }\n    case \"subscribe\" /* Subscribe */: {\n      if (typeof val.id !== \"string\") {\n        throw new Error(\n          `\"${val.type}\" message expects the 'id' property to be a string, but got ${extendedTypeof(\n            val.id\n          )}`\n        );\n      }\n      if (!val.id) {\n        throw new Error(\n          `\"${val.type}\" message requires a non-empty 'id' property`\n        );\n      }\n      if (!isObject(val.payload)) {\n        throw new Error(\n          `\"${val.type}\" message expects the 'payload' property to be an object, but got ${extendedTypeof(\n            val.payload\n          )}`\n        );\n      }\n      if (typeof val.payload.query !== \"string\") {\n        throw new Error(\n          `\"${val.type}\" message payload expects the 'query' property to be a string, but got ${extendedTypeof(\n            val.payload.query\n          )}`\n        );\n      }\n      if (val.payload.variables != null && !isObject(val.payload.variables)) {\n        throw new Error(\n          `\"${val.type}\" message payload expects the 'variables' property to be a an object or nullish or missing, but got ${extendedTypeof(\n            val.payload.variables\n          )}`\n        );\n      }\n      if (val.payload.operationName != null && extendedTypeof(val.payload.operationName) !== \"string\") {\n        throw new Error(\n          `\"${val.type}\" message payload expects the 'operationName' property to be a string or nullish or missing, but got ${extendedTypeof(\n            val.payload.operationName\n          )}`\n        );\n      }\n      if (val.payload.extensions != null && !isObject(val.payload.extensions)) {\n        throw new Error(\n          `\"${val.type}\" message payload expects the 'extensions' property to be a an object or nullish or missing, but got ${extendedTypeof(\n            val.payload.extensions\n          )}`\n        );\n      }\n      break;\n    }\n    case \"next\" /* Next */: {\n      if (typeof val.id !== \"string\") {\n        throw new Error(\n          `\"${val.type}\" message expects the 'id' property to be a string, but got ${extendedTypeof(\n            val.id\n          )}`\n        );\n      }\n      if (!val.id) {\n        throw new Error(\n          `\"${val.type}\" message requires a non-empty 'id' property`\n        );\n      }\n      if (!isObject(val.payload)) {\n        throw new Error(\n          `\"${val.type}\" message expects the 'payload' property to be an object, but got ${extendedTypeof(\n            val.payload\n          )}`\n        );\n      }\n      break;\n    }\n    case \"error\" /* Error */: {\n      if (typeof val.id !== \"string\") {\n        throw new Error(\n          `\"${val.type}\" message expects the 'id' property to be a string, but got ${extendedTypeof(\n            val.id\n          )}`\n        );\n      }\n      if (!val.id) {\n        throw new Error(\n          `\"${val.type}\" message requires a non-empty 'id' property`\n        );\n      }\n      if (!areGraphQLFormattedErrors(val.payload)) {\n        throw new Error(\n          `\"${val.type}\" message expects the 'payload' property to be an array of GraphQL errors, but got ${JSON.stringify(\n            val.payload\n          )}`\n        );\n      }\n      break;\n    }\n    case \"complete\" /* Complete */: {\n      if (typeof val.id !== \"string\") {\n        throw new Error(\n          `\"${val.type}\" message expects the 'id' property to be a string, but got ${extendedTypeof(\n            val.id\n          )}`\n        );\n      }\n      if (!val.id) {\n        throw new Error(\n          `\"${val.type}\" message requires a non-empty 'id' property`\n        );\n      }\n      break;\n    }\n    default:\n      throw new Error(`Invalid message 'type' property \"${val.type}\"`);\n  }\n  return val;\n}\nfunction parseMessage(data, reviver) {\n  return validateMessage(\n    typeof data === \"string\" ? JSON.parse(data, reviver) : data\n  );\n}\nfunction stringifyMessage(msg, replacer) {\n  validateMessage(msg);\n  return JSON.stringify(msg, replacer);\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9ncmFwaHFsLXdzQDYuMC41X2dyYXBocWxAMTYuMTEuMF93c0A4LjE3LjEvbm9kZV9tb2R1bGVzL2dyYXBocWwtd3MvZGlzdC9jb21tb24tQ0dXMTFGeWIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsaUJBQWlCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxtQkFBbUI7QUFDcEI7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELG9CQUFvQjtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdFQUF3RTtBQUN4RTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFNBQVMsMkZBQTJGLFlBQVk7QUFDOUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFNBQVMsOERBQThEO0FBQ3JGO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxTQUFTLG9FQUFvRTtBQUMzRjtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsU0FBUyx5RUFBeUU7QUFDaEc7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFNBQVMsc0dBQXNHO0FBQzdIO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxTQUFTLHVHQUF1RztBQUM5SDtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsU0FBUyx1R0FBdUc7QUFDOUg7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFNBQVMsOERBQThEO0FBQ3JGO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxTQUFTLG9FQUFvRTtBQUMzRjtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsU0FBUyw4REFBOEQ7QUFDckY7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFNBQVM7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFNBQVMscUZBQXFGO0FBQzVHO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxTQUFTLDhEQUE4RDtBQUNyRjtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsU0FBUztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELFNBQVM7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUV3USIsInNvdXJjZXMiOlsid2VicGFjazovL3VpLy4vbm9kZV9tb2R1bGVzLy5wbnBtL2dyYXBocWwtd3NANi4wLjVfZ3JhcGhxbEAxNi4xMS4wX3dzQDguMTcuMS9ub2RlX21vZHVsZXMvZ3JhcGhxbC13cy9kaXN0L2NvbW1vbi1DR1cxMUZ5Yi5qcz82MmI4Il0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIGV4dGVuZGVkVHlwZW9mKHZhbCkge1xuICBpZiAodmFsID09PSBudWxsKSB7XG4gICAgcmV0dXJuIFwibnVsbFwiO1xuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KHZhbCkpIHtcbiAgICByZXR1cm4gXCJhcnJheVwiO1xuICB9XG4gIHJldHVybiB0eXBlb2YgdmFsO1xufVxuZnVuY3Rpb24gaXNPYmplY3QodmFsKSB7XG4gIHJldHVybiBleHRlbmRlZFR5cGVvZih2YWwpID09PSBcIm9iamVjdFwiO1xufVxuZnVuY3Rpb24gaXNBc3luY0l0ZXJhYmxlKHZhbCkge1xuICByZXR1cm4gdHlwZW9mIE9iamVjdCh2YWwpW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9PT0gXCJmdW5jdGlvblwiO1xufVxuZnVuY3Rpb24gaXNBc3luY0dlbmVyYXRvcih2YWwpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KHZhbCkgJiYgdHlwZW9mIE9iamVjdCh2YWwpW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiB2YWwucmV0dXJuID09PSBcImZ1bmN0aW9uXCI7XG59XG5mdW5jdGlvbiBhcmVHcmFwaFFMRm9ybWF0dGVkRXJyb3JzKG9iaikge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheShvYmopICYmIC8vIG11c3QgYmUgYXQgbGVhc3Qgb25lIGVycm9yXG4gIG9iai5sZW5ndGggPiAwICYmIC8vIGVycm9yIGhhcyBhdCBsZWFzdCBhIG1lc3NhZ2VcbiAgb2JqLmV2ZXJ5KChvYikgPT4gXCJtZXNzYWdlXCIgaW4gb2IpO1xufVxuZnVuY3Rpb24gbGltaXRDbG9zZVJlYXNvbihyZWFzb24sIHdoZW5Ub29Mb25nKSB7XG4gIHJldHVybiByZWFzb24ubGVuZ3RoIDwgMTI0ID8gcmVhc29uIDogd2hlblRvb0xvbmc7XG59XG5cbmNvbnN0IEdSQVBIUUxfVFJBTlNQT1JUX1dTX1BST1RPQ09MID0gXCJncmFwaHFsLXRyYW5zcG9ydC13c1wiO1xuY29uc3QgREVQUkVDQVRFRF9HUkFQSFFMX1dTX1BST1RPQ09MID0gXCJncmFwaHFsLXdzXCI7XG52YXIgQ2xvc2VDb2RlID0gLyogQF9fUFVSRV9fICovICgoQ2xvc2VDb2RlMikgPT4ge1xuICBDbG9zZUNvZGUyW0Nsb3NlQ29kZTJbXCJJbnRlcm5hbFNlcnZlckVycm9yXCJdID0gNDUwMF0gPSBcIkludGVybmFsU2VydmVyRXJyb3JcIjtcbiAgQ2xvc2VDb2RlMltDbG9zZUNvZGUyW1wiSW50ZXJuYWxDbGllbnRFcnJvclwiXSA9IDQwMDVdID0gXCJJbnRlcm5hbENsaWVudEVycm9yXCI7XG4gIENsb3NlQ29kZTJbQ2xvc2VDb2RlMltcIkJhZFJlcXVlc3RcIl0gPSA0NDAwXSA9IFwiQmFkUmVxdWVzdFwiO1xuICBDbG9zZUNvZGUyW0Nsb3NlQ29kZTJbXCJCYWRSZXNwb25zZVwiXSA9IDQwMDRdID0gXCJCYWRSZXNwb25zZVwiO1xuICBDbG9zZUNvZGUyW0Nsb3NlQ29kZTJbXCJVbmF1dGhvcml6ZWRcIl0gPSA0NDAxXSA9IFwiVW5hdXRob3JpemVkXCI7XG4gIENsb3NlQ29kZTJbQ2xvc2VDb2RlMltcIkZvcmJpZGRlblwiXSA9IDQ0MDNdID0gXCJGb3JiaWRkZW5cIjtcbiAgQ2xvc2VDb2RlMltDbG9zZUNvZGUyW1wiU3VicHJvdG9jb2xOb3RBY2NlcHRhYmxlXCJdID0gNDQwNl0gPSBcIlN1YnByb3RvY29sTm90QWNjZXB0YWJsZVwiO1xuICBDbG9zZUNvZGUyW0Nsb3NlQ29kZTJbXCJDb25uZWN0aW9uSW5pdGlhbGlzYXRpb25UaW1lb3V0XCJdID0gNDQwOF0gPSBcIkNvbm5lY3Rpb25Jbml0aWFsaXNhdGlvblRpbWVvdXRcIjtcbiAgQ2xvc2VDb2RlMltDbG9zZUNvZGUyW1wiQ29ubmVjdGlvbkFja25vd2xlZGdlbWVudFRpbWVvdXRcIl0gPSA0NTA0XSA9IFwiQ29ubmVjdGlvbkFja25vd2xlZGdlbWVudFRpbWVvdXRcIjtcbiAgQ2xvc2VDb2RlMltDbG9zZUNvZGUyW1wiU3Vic2NyaWJlckFscmVhZHlFeGlzdHNcIl0gPSA0NDA5XSA9IFwiU3Vic2NyaWJlckFscmVhZHlFeGlzdHNcIjtcbiAgQ2xvc2VDb2RlMltDbG9zZUNvZGUyW1wiVG9vTWFueUluaXRpYWxpc2F0aW9uUmVxdWVzdHNcIl0gPSA0NDI5XSA9IFwiVG9vTWFueUluaXRpYWxpc2F0aW9uUmVxdWVzdHNcIjtcbiAgcmV0dXJuIENsb3NlQ29kZTI7XG59KShDbG9zZUNvZGUgfHwge30pO1xudmFyIE1lc3NhZ2VUeXBlID0gLyogQF9fUFVSRV9fICovICgoTWVzc2FnZVR5cGUyKSA9PiB7XG4gIE1lc3NhZ2VUeXBlMltcIkNvbm5lY3Rpb25Jbml0XCJdID0gXCJjb25uZWN0aW9uX2luaXRcIjtcbiAgTWVzc2FnZVR5cGUyW1wiQ29ubmVjdGlvbkFja1wiXSA9IFwiY29ubmVjdGlvbl9hY2tcIjtcbiAgTWVzc2FnZVR5cGUyW1wiUGluZ1wiXSA9IFwicGluZ1wiO1xuICBNZXNzYWdlVHlwZTJbXCJQb25nXCJdID0gXCJwb25nXCI7XG4gIE1lc3NhZ2VUeXBlMltcIlN1YnNjcmliZVwiXSA9IFwic3Vic2NyaWJlXCI7XG4gIE1lc3NhZ2VUeXBlMltcIk5leHRcIl0gPSBcIm5leHRcIjtcbiAgTWVzc2FnZVR5cGUyW1wiRXJyb3JcIl0gPSBcImVycm9yXCI7XG4gIE1lc3NhZ2VUeXBlMltcIkNvbXBsZXRlXCJdID0gXCJjb21wbGV0ZVwiO1xuICByZXR1cm4gTWVzc2FnZVR5cGUyO1xufSkoTWVzc2FnZVR5cGUgfHwge30pO1xuZnVuY3Rpb24gdmFsaWRhdGVNZXNzYWdlKHZhbCkge1xuICBpZiAoIWlzT2JqZWN0KHZhbCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgTWVzc2FnZSBpcyBleHBlY3RlZCB0byBiZSBhbiBvYmplY3QsIGJ1dCBnb3QgJHtleHRlbmRlZFR5cGVvZih2YWwpfWBcbiAgICApO1xuICB9XG4gIGlmICghdmFsLnR5cGUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYE1lc3NhZ2UgaXMgbWlzc2luZyB0aGUgJ3R5cGUnIHByb3BlcnR5YCk7XG4gIH1cbiAgaWYgKHR5cGVvZiB2YWwudHlwZSAhPT0gXCJzdHJpbmdcIikge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBNZXNzYWdlIGlzIGV4cGVjdHMgdGhlICd0eXBlJyBwcm9wZXJ0eSB0byBiZSBhIHN0cmluZywgYnV0IGdvdCAke2V4dGVuZGVkVHlwZW9mKFxuICAgICAgICB2YWwudHlwZVxuICAgICAgKX1gXG4gICAgKTtcbiAgfVxuICBzd2l0Y2ggKHZhbC50eXBlKSB7XG4gICAgY2FzZSBcImNvbm5lY3Rpb25faW5pdFwiIC8qIENvbm5lY3Rpb25Jbml0ICovOlxuICAgIGNhc2UgXCJjb25uZWN0aW9uX2Fja1wiIC8qIENvbm5lY3Rpb25BY2sgKi86XG4gICAgY2FzZSBcInBpbmdcIiAvKiBQaW5nICovOlxuICAgIGNhc2UgXCJwb25nXCIgLyogUG9uZyAqLzoge1xuICAgICAgaWYgKHZhbC5wYXlsb2FkICE9IG51bGwgJiYgIWlzT2JqZWN0KHZhbC5wYXlsb2FkKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgYFwiJHt2YWwudHlwZX1cIiBtZXNzYWdlIGV4cGVjdHMgdGhlICdwYXlsb2FkJyBwcm9wZXJ0eSB0byBiZSBhbiBvYmplY3Qgb3IgbnVsbGlzaCBvciBtaXNzaW5nLCBidXQgZ290IFwiJHt2YWwucGF5bG9hZH1cImBcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIFwic3Vic2NyaWJlXCIgLyogU3Vic2NyaWJlICovOiB7XG4gICAgICBpZiAodHlwZW9mIHZhbC5pZCAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgYFwiJHt2YWwudHlwZX1cIiBtZXNzYWdlIGV4cGVjdHMgdGhlICdpZCcgcHJvcGVydHkgdG8gYmUgYSBzdHJpbmcsIGJ1dCBnb3QgJHtleHRlbmRlZFR5cGVvZihcbiAgICAgICAgICAgIHZhbC5pZFxuICAgICAgICAgICl9YFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKCF2YWwuaWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGBcIiR7dmFsLnR5cGV9XCIgbWVzc2FnZSByZXF1aXJlcyBhIG5vbi1lbXB0eSAnaWQnIHByb3BlcnR5YFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKCFpc09iamVjdCh2YWwucGF5bG9hZCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGBcIiR7dmFsLnR5cGV9XCIgbWVzc2FnZSBleHBlY3RzIHRoZSAncGF5bG9hZCcgcHJvcGVydHkgdG8gYmUgYW4gb2JqZWN0LCBidXQgZ290ICR7ZXh0ZW5kZWRUeXBlb2YoXG4gICAgICAgICAgICB2YWwucGF5bG9hZFxuICAgICAgICAgICl9YFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiB2YWwucGF5bG9hZC5xdWVyeSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgYFwiJHt2YWwudHlwZX1cIiBtZXNzYWdlIHBheWxvYWQgZXhwZWN0cyB0aGUgJ3F1ZXJ5JyBwcm9wZXJ0eSB0byBiZSBhIHN0cmluZywgYnV0IGdvdCAke2V4dGVuZGVkVHlwZW9mKFxuICAgICAgICAgICAgdmFsLnBheWxvYWQucXVlcnlcbiAgICAgICAgICApfWBcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmICh2YWwucGF5bG9hZC52YXJpYWJsZXMgIT0gbnVsbCAmJiAhaXNPYmplY3QodmFsLnBheWxvYWQudmFyaWFibGVzKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgYFwiJHt2YWwudHlwZX1cIiBtZXNzYWdlIHBheWxvYWQgZXhwZWN0cyB0aGUgJ3ZhcmlhYmxlcycgcHJvcGVydHkgdG8gYmUgYSBhbiBvYmplY3Qgb3IgbnVsbGlzaCBvciBtaXNzaW5nLCBidXQgZ290ICR7ZXh0ZW5kZWRUeXBlb2YoXG4gICAgICAgICAgICB2YWwucGF5bG9hZC52YXJpYWJsZXNcbiAgICAgICAgICApfWBcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmICh2YWwucGF5bG9hZC5vcGVyYXRpb25OYW1lICE9IG51bGwgJiYgZXh0ZW5kZWRUeXBlb2YodmFsLnBheWxvYWQub3BlcmF0aW9uTmFtZSkgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGBcIiR7dmFsLnR5cGV9XCIgbWVzc2FnZSBwYXlsb2FkIGV4cGVjdHMgdGhlICdvcGVyYXRpb25OYW1lJyBwcm9wZXJ0eSB0byBiZSBhIHN0cmluZyBvciBudWxsaXNoIG9yIG1pc3NpbmcsIGJ1dCBnb3QgJHtleHRlbmRlZFR5cGVvZihcbiAgICAgICAgICAgIHZhbC5wYXlsb2FkLm9wZXJhdGlvbk5hbWVcbiAgICAgICAgICApfWBcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmICh2YWwucGF5bG9hZC5leHRlbnNpb25zICE9IG51bGwgJiYgIWlzT2JqZWN0KHZhbC5wYXlsb2FkLmV4dGVuc2lvbnMpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBgXCIke3ZhbC50eXBlfVwiIG1lc3NhZ2UgcGF5bG9hZCBleHBlY3RzIHRoZSAnZXh0ZW5zaW9ucycgcHJvcGVydHkgdG8gYmUgYSBhbiBvYmplY3Qgb3IgbnVsbGlzaCBvciBtaXNzaW5nLCBidXQgZ290ICR7ZXh0ZW5kZWRUeXBlb2YoXG4gICAgICAgICAgICB2YWwucGF5bG9hZC5leHRlbnNpb25zXG4gICAgICAgICAgKX1gXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSBcIm5leHRcIiAvKiBOZXh0ICovOiB7XG4gICAgICBpZiAodHlwZW9mIHZhbC5pZCAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgYFwiJHt2YWwudHlwZX1cIiBtZXNzYWdlIGV4cGVjdHMgdGhlICdpZCcgcHJvcGVydHkgdG8gYmUgYSBzdHJpbmcsIGJ1dCBnb3QgJHtleHRlbmRlZFR5cGVvZihcbiAgICAgICAgICAgIHZhbC5pZFxuICAgICAgICAgICl9YFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKCF2YWwuaWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGBcIiR7dmFsLnR5cGV9XCIgbWVzc2FnZSByZXF1aXJlcyBhIG5vbi1lbXB0eSAnaWQnIHByb3BlcnR5YFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKCFpc09iamVjdCh2YWwucGF5bG9hZCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGBcIiR7dmFsLnR5cGV9XCIgbWVzc2FnZSBleHBlY3RzIHRoZSAncGF5bG9hZCcgcHJvcGVydHkgdG8gYmUgYW4gb2JqZWN0LCBidXQgZ290ICR7ZXh0ZW5kZWRUeXBlb2YoXG4gICAgICAgICAgICB2YWwucGF5bG9hZFxuICAgICAgICAgICl9YFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgXCJlcnJvclwiIC8qIEVycm9yICovOiB7XG4gICAgICBpZiAodHlwZW9mIHZhbC5pZCAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgYFwiJHt2YWwudHlwZX1cIiBtZXNzYWdlIGV4cGVjdHMgdGhlICdpZCcgcHJvcGVydHkgdG8gYmUgYSBzdHJpbmcsIGJ1dCBnb3QgJHtleHRlbmRlZFR5cGVvZihcbiAgICAgICAgICAgIHZhbC5pZFxuICAgICAgICAgICl9YFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKCF2YWwuaWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGBcIiR7dmFsLnR5cGV9XCIgbWVzc2FnZSByZXF1aXJlcyBhIG5vbi1lbXB0eSAnaWQnIHByb3BlcnR5YFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKCFhcmVHcmFwaFFMRm9ybWF0dGVkRXJyb3JzKHZhbC5wYXlsb2FkKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgYFwiJHt2YWwudHlwZX1cIiBtZXNzYWdlIGV4cGVjdHMgdGhlICdwYXlsb2FkJyBwcm9wZXJ0eSB0byBiZSBhbiBhcnJheSBvZiBHcmFwaFFMIGVycm9ycywgYnV0IGdvdCAke0pTT04uc3RyaW5naWZ5KFxuICAgICAgICAgICAgdmFsLnBheWxvYWRcbiAgICAgICAgICApfWBcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIFwiY29tcGxldGVcIiAvKiBDb21wbGV0ZSAqLzoge1xuICAgICAgaWYgKHR5cGVvZiB2YWwuaWQgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGBcIiR7dmFsLnR5cGV9XCIgbWVzc2FnZSBleHBlY3RzIHRoZSAnaWQnIHByb3BlcnR5IHRvIGJlIGEgc3RyaW5nLCBidXQgZ290ICR7ZXh0ZW5kZWRUeXBlb2YoXG4gICAgICAgICAgICB2YWwuaWRcbiAgICAgICAgICApfWBcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmICghdmFsLmlkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBgXCIke3ZhbC50eXBlfVwiIG1lc3NhZ2UgcmVxdWlyZXMgYSBub24tZW1wdHkgJ2lkJyBwcm9wZXJ0eWBcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIG1lc3NhZ2UgJ3R5cGUnIHByb3BlcnR5IFwiJHt2YWwudHlwZX1cImApO1xuICB9XG4gIHJldHVybiB2YWw7XG59XG5mdW5jdGlvbiBwYXJzZU1lc3NhZ2UoZGF0YSwgcmV2aXZlcikge1xuICByZXR1cm4gdmFsaWRhdGVNZXNzYWdlKFxuICAgIHR5cGVvZiBkYXRhID09PSBcInN0cmluZ1wiID8gSlNPTi5wYXJzZShkYXRhLCByZXZpdmVyKSA6IGRhdGFcbiAgKTtcbn1cbmZ1bmN0aW9uIHN0cmluZ2lmeU1lc3NhZ2UobXNnLCByZXBsYWNlcikge1xuICB2YWxpZGF0ZU1lc3NhZ2UobXNnKTtcbiAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KG1zZywgcmVwbGFjZXIpO1xufVxuXG5leHBvcnQgeyBDbG9zZUNvZGUgYXMgQywgREVQUkVDQVRFRF9HUkFQSFFMX1dTX1BST1RPQ09MIGFzIEQsIEdSQVBIUUxfVFJBTlNQT1JUX1dTX1BST1RPQ09MIGFzIEcsIE1lc3NhZ2VUeXBlIGFzIE0sIGlzQXN5bmNHZW5lcmF0b3IgYXMgYSwgaXNBc3luY0l0ZXJhYmxlIGFzIGIsIGlzT2JqZWN0IGFzIGksIGxpbWl0Q2xvc2VSZWFzb24gYXMgbCwgcGFyc2VNZXNzYWdlIGFzIHAsIHN0cmluZ2lmeU1lc3NhZ2UgYXMgcywgdmFsaWRhdGVNZXNzYWdlIGFzIHYgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/.pnpm/graphql-ws@6.0.5_graphql@16.11.0_ws@8.17.1/node_modules/graphql-ws/dist/common-CGW11Fyb.js\n");

/***/ })

};
;